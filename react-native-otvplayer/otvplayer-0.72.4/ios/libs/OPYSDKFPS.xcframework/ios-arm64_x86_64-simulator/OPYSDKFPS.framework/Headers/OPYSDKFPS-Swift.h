#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
#ifndef OPYSDKFPS_SWIFT_H
#define OPYSDKFPS_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import AVFoundation;
@import CoreFoundation;
@import CoreMedia;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#import <OPYSDKFPS/OPYSDKFPS.h>

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="OPYSDKFPS",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)



/// Network analytics related to adaptive streaming
SWIFT_PROTOCOL("_TtP9OPYSDKFPS17AdaptiveStreaming_")
@protocol AdaptiveStreaming
/// Returns an array of bitrates available in the playlist
/// note:
/// This function will make a seperate request for the Master playlist to return all the availableBitrates. This request is only done once you call this function and only on the first time you call it for that contnet. Every subsiquent call on the same content does not requst the playlist again.
///
/// returns:
/// an array of bitrates available in the playlist, or nil if unknown
- (NSArray<NSNumber *> * _Nullable)availableBitrates SWIFT_WARN_UNUSED_RESULT;
/// Returns the bitrate from the playlist that has been selected for playback, in bits per second
///
/// returns:
/// the bitrate from the playlist that has been selected for playback, or 0 if unknown
- (double)selectedBitrate SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of times the bitrate has switched.
///
/// returns:
/// the number of times the bitrate has switched.
- (NSInteger)bitrateSwitches SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of times the bitrate has switched to a lower bitrate.
///
/// returns:
/// the number of times the bitrate has switched to a lower bitrate.
- (NSInteger)bitrateDowngrade SWIFT_WARN_UNUSED_RESULT;
/// Returns the Video and Audio track’s average bit rate, in bits per second.
///
/// returns:
/// the Video and Audio track’s average bit rate, in bits per second.
- (NSInteger)averageBitrate SWIFT_WARN_UNUSED_RESULT;
/// Returns the video track’s average bit rate, in bits per second.
///
/// returns:
/// the  video track’s average bit rate, in bits per second.
- (NSInteger)averageVideoBitrate SWIFT_WARN_UNUSED_RESULT;
/// Returns the audio track’s average bit rate, in bits per second.
///
/// returns:
/// the  audio track’s average bit rate, in bits per second.
- (NSInteger)averageAudioBitrate SWIFT_WARN_UNUSED_RESULT;
@end


/// Entry point for the Thumbnail on Seek functionality
SWIFT_CLASS("_TtC9OPYSDKFPS15AssetThumbnails")
@interface AssetThumbnails : NSObject
/// Default constructor used to build the <code>AssetThumbnail</code> class
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSString;

/// Network analytics related to the content server
SWIFT_PROTOCOL("_TtP9OPYSDKFPS13ContentServer_")
@protocol ContentServer
/// Returns the IP address of the content server
///
/// returns:
/// the IP address of the content server for the last segment, or nil if unknown
- (NSString * _Nullable)finalIPAddress SWIFT_WARN_UNUSED_RESULT;
/// Returns the URL of the selected playlist, after any redirects
///
/// returns:
/// the URL of the selected playlist, or nil if unknown
- (NSString * _Nullable)finalURL SWIFT_WARN_UNUSED_RESULT;
/// Returns the original URL of the stream
///
/// returns:
/// the original URL of the stream, or nil if unknown
- (NSString * _Nullable)url SWIFT_WARN_UNUSED_RESULT;
/// Returns a count of changes to the server address over the last uninterrupted period of playback.
///
/// returns:
/// the number of server address changes or -1 if unknown
- (NSInteger)numberOfServerAddressChanges SWIFT_WARN_UNUSED_RESULT;
@end





/// The <code>IOTVLogProvider</code> protocol defines a method that allows application to receive the log message from SDK in production build.
SWIFT_PROTOCOL("_TtP9OPYSDKFPS15IOTVLogProvider_")
@protocol IOTVLogProvider <NSObject>
/// This method is used by SDK to pass the log message to application.
/// \param xLog log message
///
- (void)logProviderWithXLog:(NSString * _Nonnull)xLog;
@end



/// Network analytics related to network usage
SWIFT_PROTOCOL("_TtP9OPYSDKFPS12NetworkUsage_")
@protocol NetworkUsage
/// Returns the number of bytes downloaded so far
///
/// returns:
/// the number of bytes downloaded so far
- (int64_t)bytesDownloaded SWIFT_WARN_UNUSED_RESULT;
/// Returns the empirical throughput, in bits per second, across all media downloaded
///
/// returns:
/// the throughput, in bits per second
- (double)downloadBitrate SWIFT_WARN_UNUSED_RESULT;
/// Returns the video track’s average bit rate, in bits per second
///
/// returns:
/// the video track’s average bit rate, in bits per second
- (double)downloadBitrateAverage SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of media read requests from the server to this client
///
/// returns:
/// The number of media read requests from the server to this client or -1 if unknown
- (NSInteger)numberOfMediaRequests SWIFT_WARN_UNUSED_RESULT;
/// Returns the accumulated duration, in seconds, of active network transfer of bytes
///
/// returns:
/// the accumulated duration, in seconds, of active network transfer of bytes or -1 if unknown
- (NSTimeInterval)transferDuration SWIFT_WARN_UNUSED_RESULT;
/// Returns the total number of times that downloading the segments took too long.
///
/// returns:
/// the total number of times that downloading the segments took too long or -1 if unknown
- (NSInteger)downloadsOverdue SWIFT_WARN_UNUSED_RESULT;
@end

@class OTVNetworkAnalytics;
@class OTVPlaybackAnalytics;
@class UIView;
@class AVPlayerItem;
@class NSURL;
enum OTVTrackType : NSInteger;
@class OTVTrackInfo;
@protocol OTVTracksChangedListener;

SWIFT_CLASS("_TtC9OPYSDKFPS11OTVAVPlayer")
@interface OTVAVPlayer : AVPlayer
/// Network analytics for the player
@property (nonatomic, readonly, strong) OTVNetworkAnalytics * _Nullable networkAnalytics;
/// Playback analytics for the player
@property (nonatomic, readonly, strong) OTVPlaybackAnalytics * _Nullable playbackAnalytics;
/// A view for rendering non-native subtitles to. This view should be at least as large as the relevant AVPlayerLayer.videoRect, but no wider.
@property (nonatomic, strong) UIView * _Nullable subtitleView;
/// :nodoc:
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Private init with AVPlayerItem which should not be called outside. Creates an instance of <code>OTVAVPlayer</code> using an <code>AVPlayerItem</code>.
/// Make sure the item is initialized with OTVAVPlayerItem, otherwise a fatal error will be raised.
/// \param item <code>AVPlayerItem</code> item to be played.
///
- (nonnull instancetype)initWithPlayerItem:(AVPlayerItem * _Nullable)item OBJC_DESIGNATED_INITIALIZER;
/// Creates an instance of <code>OTVAVPlayer</code> using a URL.
/// note:
/// Calling this function before loading the <code>OTVSDK</code> (with <code>OTVSDK.load()</code> or <code>OTVSDK.load(licence)</code>) will result in a playback error.
/// \param URL URL of the content to be played.
///
- (nonnull instancetype)initWithURL:(NSURL * _Nonnull)URL;
/// Replaces the current item being played with another <code>AVPlayerItem</code>.
/// note:
/// the item should be an <code>OTVAVPlayerItem</code>, otherwise it will be ignored.
/// \param item <code>AVPlayerItem</code> to be played.
///
- (void)replaceCurrentItemWithPlayerItem:(AVPlayerItem * _Nullable)item;
/// :nodoc:
- (void)play;
/// :nodoc:
- (void)playImmediatelyAtRate:(float)rate;
/// Returns an array of tracks available for the specified type.
/// \param type The type of tracks to return
///
- (NSArray<OTVTrackInfo *> * _Nonnull)tracksWithType:(enum OTVTrackType)type SWIFT_WARN_UNUSED_RESULT;
/// Returns the selected track index for the specified type, or -1 if nothing is selected.
/// \param type The type of track to return
///
- (NSInteger)selectedTrackWithType:(enum OTVTrackType)type SWIFT_WARN_UNUSED_RESULT;
/// Selects the specified track
/// \param type The type of the track to select
///
/// \param index The index of the track to select
///
- (void)selectTrackWithType:(enum OTVTrackType)type index:(NSInteger)index;
/// Deselects the specified track.
/// \param type The type of the track to deselect
///
/// \param index The index of the track to deselect
///
- (void)deselectTrackWithType:(enum OTVTrackType)type index:(NSInteger)index;
/// Registers a listener for when the tracks available change.
/// The listener may be called at any point during playback.
/// \param tracksChangedListener The listener
///
- (void)registerWithTracksChangedListener:(id <OTVTracksChangedListener> _Nonnull)tracksChangedListener;
/// Unregisters a listener for when the tracks available change
/// \param tracksChangedListener The listener
///
- (void)unregisterWithTracksChangedListener:(id <OTVTracksChangedListener> _Nonnull)tracksChangedListener;
/// Add an external SRT subttile from a given URL
/// \param subtitleURL The URL of the subtitle
///
/// \param mimeType The mimeType of the subtitle
///
/// \param language The Language of the subtitle
///
- (void)addSubtitleWithUrl:(NSString * _Nonnull)subtitleURL mimeType:(NSString * _Nonnull)mimeType language:(NSString * _Nonnull)language;
@end


@class AVAsset;

/// <code>OTVAVPlayerItem</code> is derived from <code>AVPlayerItem</code>, please refer to apple’s documentation for further information.
SWIFT_CLASS("_TtC9OPYSDKFPS15OTVAVPlayerItem")
@interface OTVAVPlayerItem : AVPlayerItem
/// The content of HLS playlist. It’s a key path can be observed.
@property (nonatomic, copy) NSString * _Nonnull metadata;
/// Creates an instance of <code>OTVAVPlayerItem</code>.
/// \param asset an instance of <code>OTVAVURLAsset</code>
///
/// \param automaticallyLoadedAssetKeys An array of strings, each representing a property defined by <code>AVAsset</code>
///
- (nonnull instancetype)initWithAsset:(AVAsset * _Nonnull)asset automaticallyLoadedAssetKeys:(NSArray<NSString *> * _Nullable)automaticallyLoadedAssetKeys SWIFT_UNAVAILABLE;
/// Creates an instance of <code>OTVAVPlayerItem</code>.
/// \param asset an AVAsset, Must be <code>OTVAVURLAsset</code>, otherwise get <code>fatalError</code>
///
- (nonnull instancetype)initWithAsset:(AVAsset * _Nonnull)asset;
/// Creates an instance of <code>OTVAVPlayerItem</code>.
/// \param URL a URL.
///
- (nonnull instancetype)initWithURL:(NSURL * _Nonnull)URL;
@end

@class NSDate;

@interface OTVAVPlayerItem (SWIFT_EXTENSION(OPYSDKFPS))
- (void)seekToTime:(CMTime)time toleranceBefore:(CMTime)toleranceBefore toleranceAfter:(CMTime)toleranceAfter completionHandler:(void (^ _Nullable)(BOOL))completionHandler;
- (BOOL)seekToDate:(NSDate * _Nonnull)date completionHandler:(void (^ _Nullable)(BOOL))completionHandler SWIFT_WARN_UNUSED_RESULT;
@end


/// <code>OTVAVURLAsset</code> is used for streams encrypted with Apple’s FairPlay Streaming (FPS).
/// It is derived from <code>AVURLAsset</code>, please refer to apple’s documentation for further information.
SWIFT_CLASS("_TtC9OPYSDKFPS13OTVAVURLAsset")
@interface OTVAVURLAsset : AVURLAsset
/// Initializes an instance of <code>OTVAVURLAsset</code> for inspection of a media resource.
/// \param URL An instance of <code>NSURL</code> that references a media resource.
///
/// \param options An instance of <code>NSDictionary</code> that contains keys for specifying options for the initialization of the <code>OTVAVURLAsset</code>. See <code>AVURLAssetPreferPreciseDurationAndTimingKey</code> and <code>AVURLAssetReferenceRestrictionsKey</code>.
///
///
/// returns:
/// An instance of <code>AVURLAsset</code>.
- (nonnull instancetype)initWithURL:(NSURL * _Nonnull)URL options:(NSDictionary<NSString *, id> * _Nullable)options OBJC_DESIGNATED_INITIALIZER;
@end

@class NSData;
@class AVContentKeySession;
@class AVContentKeyRequest;

/// The <code>OTVLicenseDelegate</code> protocol defines methods that allows your code to handle the FPS request while playing a <em>FairPlay</em> encrypted stream.
SWIFT_PROTOCOL("_TtP9OPYSDKFPS18OTVLicenseDelegate_")
@protocol OTVLicenseDelegate <NSObject>
/// Returns the scheme that the integrator uses in the <code>EXT-X-KEY</code> URI.
///
/// returns:
/// String: Of Scheme.
- (NSString * _Nullable)scheme SWIFT_WARN_UNUSED_RESULT;
/// Returns the content identifier that the integrator uses in the server side.
/// \param url URL
/// The URL is the <code>EXT-X-KEY</code> URI, which may contain the information about the content identifier.
/// (The integrator decides what this parameter contains.)
///
///
/// returns:
/// Data contains the content identifier.
- (NSData * _Nullable)contentIdentifierWithUrl:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Returns the certificate that integrator uses in the server side.
///
/// returns:
/// Data contains the certificate.
- (NSData * _Nullable)certificate SWIFT_WARN_UNUSED_RESULT;
/// Returns the Content Key Context (CKC) message from the server side that is used to decrypt the FairPlay stream.
/// remark:
///
/// This delegate function only supports one asset playout. Customers should implement the <code>ckcMessageWithID(spc:assetID:)</code> when playback multistream in concurrency.
/// seealso:
/// <code>ckcMessageWithID(spc:assetID:)</code>, <code>ckcMessageWith(spc:assetID:session:keyRequest:)</code>
/// \param spc Data The Server Playback Context (SPC) is the payload produced from AVFoundation.
///
///
/// returns:
/// Data contains the Content Key Context (CKC) message.
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc SWIFT_WARN_UNUSED_RESULT;
/// Returns the Content Key Context (CKC) message from the server side that is used to decrypt the FairPlay stream.
/// \param spc Data The Server Playback Context (SPC) is the payload produced from AVFoundation.
///
/// \param assetID contentID from HLS Playlist. Multi playback should depend on the value to request different license.
///
///
/// returns:
/// Data contains the Content Key Context (CKC) message.
- (NSData * _Nullable)ckcMessageWithIDWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
/// Returns the Content Key Context (CKC) message from the server side that is used to decrypt the FairPlay stream.
/// remark:
///
/// In deployments where Secure Session Management is enforced by a short duration FPS license (“license-renew”),
/// the session and keyRequest values may be saved and later used to trigger renewal of the expiring license using:
/// <code>keySession.renewExpiringResponseData(for: keyRequest)</code>
/// \param spc Data The Server Playback Context (SPC) is the payload produced from AVFoundation.
///
/// \param assetID contentID from HLS Playlist. Multi playback should depend on the value to request different license.
///
/// \param session the AVContentKeySession for which the CKC is required
///
/// \param keyRequest the originating AVContentKeyRequest
///
///
/// returns:
/// Data contains the Content Key Context (CKC) message.
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID session:(AVContentKeySession * _Nonnull)session keyRequest:(AVContentKeyRequest * _Nonnull)keyRequest SWIFT_WARN_UNUSED_RESULT;
@end


/// <code>OTVCommonLicenceDelegate</code> is a default implementation of <code>OTVLicenseDelegate</code>.
SWIFT_CLASS("_TtC9OPYSDKFPS24OTVCommonLicenseDelegate")
@interface OTVCommonLicenseDelegate : NSObject <OTVLicenseDelegate>
/// Creates an instance of <code>OTVCommonLicenceDelegate</code>.
/// \param certificateURL URL of certificate file.
///
/// \param licenseURL URL of license request.
///
- (nonnull instancetype)initWithCertificateURL:(NSURL * _Nonnull)certificateURL licenseURL:(NSURL * _Nonnull)licenseURL OBJC_DESIGNATED_INITIALIZER;
/// Returns scheme for fairplay “skd”. This function can be override for mutltidrm. More in <code>OTVLicenseDelegate</code>.
- (NSString * _Nullable)scheme SWIFT_WARN_UNUSED_RESULT;
/// Returns the content identifier. This function can be override for mutltidrm. More in <code>OTVLicenseDelegate</code>.
- (NSData * _Nullable)contentIdentifierWithUrl:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Returns the certificate. This function can be override for mutltidrm. More in <code>OTVLicenseDelegate</code>.
- (NSData * _Nullable)certificate SWIFT_WARN_UNUSED_RESULT;
/// Returns the Content Key Context (CKC) message.
/// This function can be override for mutltidrm. More in <code>OTVLicenseDelegate</code>.
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc SWIFT_WARN_UNUSED_RESULT;
/// Returns the Content Key Context (CKC) message.
/// This function can be override for mutltidrm. More in <code>OTVLicenseDelegate</code>.
- (NSData * _Nullable)ckcMessageWithIDWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID session:(AVContentKeySession * _Nonnull)session keyRequest:(AVContentKeyRequest * _Nonnull)keyRequest SWIFT_WARN_UNUSED_RESULT;
/// Returns the license HTTP Request custom headers.
/// This function must be overridden for multidrm.
/// Default returns empty Dictionary. If a nil Dictionary is returned the licence request is not sent.
/// \param assetID client should use passed assetID to generate correctly http headers.
///
- (NSDictionary<NSString *, NSString *> * _Nullable)generateHTTPHeadersWithAssetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
- (NSURL * _Nonnull)getLicenseRequestUrl SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)getCkcFromLicenseResponseWithResponse:(NSDictionary<NSString *, id> * _Nonnull)response SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSCoder;

/// A container view that creates an <code>AVPlayerLayer</code> and subtitle view,
/// managing the interactions with <code>OTVAVPlayer</code> for easy integration.
/// Optionally custom overlays can be added on top of the video/subtitle content
/// through the ‘customOverlayView’ property. These views will sit below any optionally
/// bound <code>OTVWatermark</code>.
/// Any subviews added in storyboard or interface builder will be automatically moved
/// onto the customOverlayView. Note that this process recreates any auto layout constraints
/// so any constraints connected to an IBOutlet will be lost.
SWIFT_CLASS("_TtC9OPYSDKFPS16OTVContainerView")
@interface OTVContainerView : UIView
/// :nodoc:
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// This function has no effect. Instead you should add your views to the customOverlayView property
- (void)addSubview:(UIView * _Nonnull)view;
/// This function has no effect. Instead you should add your views to the customOverlayView property
- (void)insertSubview:(UIView * _Nonnull)view atIndex:(NSInteger)index;
/// This function has no effect. Instead you should add your views to the customOverlayView property
- (void)insertSubview:(UIView * _Nonnull)view aboveSubview:(UIView * _Nonnull)siblingSubview;
/// This function has no effect. Instead you should add your views to the customOverlayView property
- (void)insertSubview:(UIView * _Nonnull)view belowSubview:(UIView * _Nonnull)siblingSubview;
/// This function has no effect. Reordering of views is not permitted, you may want to make use of the customOverlayView property
- (void)bringSubviewToFront:(UIView * _Nonnull)view;
/// This function has no effect. Reordering of views is not permitted, you may want to make use of the customOverlayView property
- (void)sendSubviewToBack:(UIView * _Nonnull)view;
/// This function has no effect. Reordering of views is not permitted, you may want to make use of the customOverlayView property
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;
@end

enum OTVLicenseRequestType : NSInteger;
@class OTVSSMLicenseResponse;

/// The OTVCustomerSSMCallback protocol imposes a requirement for the license and heartbeat functions.
/// An instance using this protocol would then be used by OTVCustomerSSMDelegate to provide the necessary protocol functionality.
SWIFT_PROTOCOL("_TtP9OPYSDKFPS22OTVCustomerSSMCallback_")
@protocol OTVCustomerSSMCallback <NSObject>
/// Returns the license continaining Content Key Context (CKC) message, and heartbeat period.
/// \param keySystem String corresponding to the desired key system (Fairplay for iOS)
///
/// \param payload token for license retrieval
///
/// \param licenseType “license-request” (inital) or “license-renew” (subsequent periodic renewal)
///
///
/// returns:
/// OTVSSMLicenseResponse containing the license data and the heartbeat period.
- (OTVSSMLicenseResponse * _Nonnull)licenseWithKeySystem:(NSString * _Nonnull)keySystem payload:(NSData * _Nonnull)payload licenseType:(enum OTVLicenseRequestType)licenseType SWIFT_WARN_UNUSED_RESULT;
/// Calls the application supplied heartbeat function
- (void)heartbeat;
@end


/// The OTVCustomerSSMDelegate class provides default implemetation to conform to the <code>OTVLicenseDelegate</code> protocol.
/// When a license is requested, it will use the license callback from the <code>OTVCustomerSSMCallback</code> conforming delegate, expecting
/// a response <code>OTVSSMLicenseResponse</code> containing the license data and a heartbeat period in seconds.
/// On receipt of a non-zero positive heartbeat period the first license request will start the heartbeat, starting at 0+heartbeat seconds.
/// It is the respoisibility of the calling application to stop the heartbeat when required by calling the ‘reset’ function.
SWIFT_CLASS("_TtC9OPYSDKFPS22OTVCustomerSSMDelegate")
@interface OTVCustomerSSMDelegate : NSObject <OTVLicenseDelegate>
/// Returns the certificate that integrator uses in the server side.
- (NSData * _Nullable)certificate SWIFT_WARN_UNUSED_RESULT;
/// Returns the scheme that the integrator uses in the <code>EXT-X-KEY</code> URI.
- (NSString * _Nullable)scheme SWIFT_WARN_UNUSED_RESULT;
/// Returns the content identifier that the integrator uses in the server side.
- (NSData * _Nullable)contentIdentifierWithUrl:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// ckcMessage is part of the <code>OTVLicenseDelegate</code> protocol
/// Here we use it to call the license callback supplied by the calling application and, if sucessful, to also start the heartbeat, calling the supplied heartbeat callback
/// \param spc payload passed to the external license request callback
///
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (NSData * _Nullable)ckcMessageWithIDWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID session:(AVContentKeySession * _Nonnull)session keyRequest:(AVContentKeyRequest * _Nonnull)keyRequest SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class OTVDRMInfo;

SWIFT_CLASS("_TtC9OPYSDKFPS6OTVDRM")
@interface OTVDRM : NSObject
/// The shared <code>OTVDRMInfo</code> instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) OTVDRM * _Nonnull shared;)
+ (OTVDRM * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// Returns the DRMInfo supported for the device.
///
/// returns:
/// An array of OTVDRMInfo objects for the users device.
- (NSArray<OTVDRMInfo *> * _Nonnull)getDRMInfo SWIFT_WARN_UNUSED_RESULT;
/// Returns the OTVDRMInfo support of the contentType passed in.
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     drmName: Name of the Drm, the only support DRM on iOS FPS is com.apple.fps
///   </li>
///   <li>
///     mediaType: Not needed for this platform, just pass an empty string.
///   </li>
///   <li>
///     contentType: The contentType used for the detection: “MIMEType;codecs=hvc1” && “MIMEType;codecs=avc1 are the only two supported in this call”
///   </li>
/// </ul>
///
/// returns:
/// An array of OTVDRMInfo objects for the users device based on if the contentType passed is supported and the security level of that support.
- (NSArray<OTVDRMInfo *> * _Nonnull)getDRMInfoWithDrmName:(NSString * _Nonnull)drmName mediaType:(NSString * _Nonnull)mediaType contentType:(NSString * _Nonnull)contentType SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

enum OTVDRMSecurityLevel : NSInteger;

/// OTVDrmInfo class represents the capability and security level for a DRM key system and content type
/// Currently the only two supported Codecs for this class are AVC1 and HVC1
/// HVC1 codec is only supported on devices newer then iOS 11 and depending on the devices the DRM security level will differ between otvDRMSLHWDecode & otvDRMSLSW.
/// If a device is older than iOS 11 this api will return a nil OTVDRMInfo object inside of the array for HVC1 codecs.
SWIFT_CLASS("_TtC9OPYSDKFPS10OTVDRMInfo")
@interface OTVDRMInfo : NSObject
/// Name of the Drm, the only support DRM on iOS FPS is com.apple.fps
@property (nonatomic, readonly, copy) NSString * _Nullable name;
/// The contentType used for the detection: “MIMEType;codecs=hvc1” && “MIMEType;codecs=avc1” are the only two supported in this call
@property (nonatomic, readonly, copy) NSString * _Nullable contentType;
/// The security level detected from Drm
@property (nonatomic, readonly) enum OTVDRMSecurityLevel securityLevel;
@property (nonatomic, readonly, copy) NSString * _Nonnull securityLevelName;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// OTVDrmSecurityLevel represents the rated security for the different codecs
typedef SWIFT_ENUM(NSInteger, OTVDRMSecurityLevel, open) {
  OTVDRMSecurityLevelOtvDRMSLUknown = 0,
  OTVDRMSecurityLevelOtvDRMSLSW = 1,
  OTVDRMSecurityLevelOtvDRMSLHWCrypt = 2,
  OTVDRMSecurityLevelOtvDRMSLHWDecode = 3,
};


/// The <code>OTVDRMManager</code> class sets up an instance of DRM based upon <code>OTVLicenseDelegate</code>.
SWIFT_CLASS("_TtC9OPYSDKFPS13OTVDRMManager")
@interface OTVDRMManager : NSObject
/// The shared <code>OTVDRMManager</code> instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) OTVDRMManager * _Nonnull shared;)
+ (OTVDRMManager * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Set the license delegate for <code>OTVDRMManager</code> based on <code>OTVLicenseDelegate</code>.
/// note:
/// The delegate is held using a zeroing-weak reference, so it has a value of nil after it has been deallocated outside. Ensure the delegate is retained until it is no longer needed by player.
/// \param delegate An instance of <code>OTVLicenseDelegate</code>.
///
- (void)setLicenseDelegate:(id <OTVLicenseDelegate> _Nonnull)delegate;
- (void)requestLicenseWithIdentifier:(NSString * _Nonnull)identifier license:(NSDictionary<NSString *, id> * _Nullable)options;
/// Check is license is persisted
/// This function is called to determing if a license is persisted or not.
/// \param identifier license identifier.  Usually comes from playlist.  For <em>FairPlay</em>, it should be <code>skd://.....</code>
///
///
/// returns:
/// <code>true</code> - the license exists or <code>false</code> - the license does not exist.
- (BOOL)isLicensePersistedWithIdentifier:(NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
/// Erase the license persistence on the local storage.
/// \param identifier license identifier. same format when used in <code>requestLicense</code>.
///
///
/// returns:
/// <code>true</code> - the license has successfully been erased from local system.
/// <code>false</code> - the license does not exist.
- (BOOL)eraseOfflineLicenseWithIdentifier:(NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
- (void)renewLicenseWithIdentifier:(NSString * _Nonnull)identifier license:(NSDictionary<NSString *, id> * _Nullable)options;
@end



/// <code>OTVDefaultLicenseDelegate</code> is a default implementataion of License request class.
SWIFT_CLASS("_TtC9OPYSDKFPS25OTVDefaultLicenseDelegate")
@interface OTVDefaultLicenseDelegate : OTVCommonLicenseDelegate
/// Set license HTTP requesting headers
/// \param parameters dictionary of HTTP request headers
///
- (void)setHTTPHeaderWithParameters:(NSDictionary<NSString *, NSString *> * _Nonnull)parameters;
/// Overrided function to pass setted HTTP header for license request. It just return setted http header by call setHTTPHeader
/// remark:
///
/// <code>OTVDefaultLicenseDelegate</code> only support one playback instance. If you want to support multiple playback, inheret from <code>OTVCommonLicenseDelegate</code>, override the same function to generate different HTTP header based on assetID
- (NSDictionary<NSString *, NSString *> * _Nullable)generateHTTPHeadersWithAssetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCertificateURL:(NSURL * _Nonnull)certificateURL licenseURL:(NSURL * _Nonnull)licenseURL OBJC_DESIGNATED_INITIALIZER;
@end

/// ObjectiveC compatible enumeration of the possible errors of a persistence asset.
typedef SWIFT_ENUM(NSInteger, OTVDownloadError, open) {
/// No error
  OTVDownloadErrorNoError = 0,
/// An unknown or unexpected error occured.
  OTVDownloadErrorUnknownError = 1,
/// An error happens in download task
  OTVDownloadErrorDownloadTaskError = 2,
/// An error happends when requesting the license
  OTVDownloadErrorLicenseRequestError = 3,
/// An error happends when downloading the manifest
  OTVDownloadErrorManifestDownloadError = 4,
/// An error happends when parsing the manifest
  OTVDownloadErrorManifestParseError = 5,
/// An error indicates downloading a  LIVE content is not supported
  OTVDownloadErrorUnsupportedLiveError = 6,
/// An error indicates there is not enough space on device
  OTVDownloadErrorInsufficientSpaceError = 7,
};


/// An instance of a player event
SWIFT_CLASS("_TtC9OPYSDKFPS8OTVEvent")
@interface OTVEvent : NSObject
/// Initailize <code>OTVEvent</code> instance with parameters
/// \param timestamp the timestamp of the event
///
/// \param type the type of the event. SDK generated events will have types from <code>EventType</code>
///
/// \param command the command of the event. SDK generated events will have commands from <code>EventCommand</code>
///
/// \param extra optional extra information for the event. SDK generated events will have extras formatted as a JSON string, with keys from <code>ExtraKey</code>
///
///
/// returns:
/// an event instance
- (nonnull instancetype)initWithTimestamp:(NSDate * _Nonnull)timestamp type:(NSString * _Nonnull)type command:(NSString * _Nonnull)command extra:(NSString * _Nullable)extra OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A timeline of events generated by the SDK
SWIFT_CLASS("_TtC9OPYSDKFPS16OTVEventTimeline")
@interface OTVEventTimeline : NSObject
/// The global instance of the event timeline
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) OTVEventTimeline * _Nonnull shared;)
+ (OTVEventTimeline * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Set whether the timeline should capture events or not.
/// \param enable whether events added to the timeline should be kept or not
///
- (void)enableTimeline:(BOOL)enable;
/// Returns whether the timeline is enabled for capturing events.
- (BOOL)isEnabled SWIFT_WARN_UNUSED_RESULT;
/// Returns all events that have been recorded.
- (NSArray<OTVEvent *> * _Nonnull)getTimelineList SWIFT_WARN_UNUSED_RESULT;
/// Returns the latest events that have been recorded, up to the specified limit.
/// \param limit The max number of latest events to return
///
- (NSArray<OTVEvent *> * _Nonnull)getTimelineListWithLimit:(NSInteger)limit SWIFT_WARN_UNUSED_RESULT;
/// Returns the events that were recorded between the specified Dates.
/// \param fromDate The earliest Date for events to include
///
/// \param toDate The latest Date for events to include
///
- (NSArray<OTVEvent *> * _Nonnull)getTimelineListFrom:(NSDate * _Nonnull)fromDate to:(NSDate * _Nonnull)toDate SWIFT_WARN_UNUSED_RESULT;
/// Returns all the events that have been recorded with the specified type.
/// \param type The type of events to return
///
- (NSArray<OTVEvent *> * _Nonnull)getTimelineListWithType:(NSString * _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Adds the specified event data to the timeline
/// \param type The type of the event
///
/// \param command The command of the event
///
/// \param extra Optional extra information for the event
///
- (void)addToTimelineWithType:(NSString * _Nonnull)type command:(NSString * _Nonnull)command extra:(NSString * _Nullable)extra;
/// Removes all events from the timeline that were added prior to the specified Date.
/// \param olderThan The reference Date to remove logs earlier than
///
- (void)removeTimelineWithOlderThan:(NSDate * _Nonnull)olderThan;
@end


/// Analyzer for <code>OTVEventTimeline</code> to report startup/zapping time.
/// note:
/// If you are playing back two streams at the same time the results from this class are undefined.
SWIFT_CLASS("_TtC9OPYSDKFPS24OTVEventTimelineAnalyzer")
@interface OTVEventTimelineAnalyzer : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// <code>OTVIFrameThumbnailError</code> is an enum that represent they type of error associated with OTVThumbnail I-Frames
typedef SWIFT_ENUM_NAMED(NSInteger, OTVThumbnailError, "OTVIFrameThumbnailError", open) {
  OTVThumbnailErrorPositionError = 1,
  OTVThumbnailErrorItemError = 2,
};


SWIFT_CLASS("_TtC9OPYSDKFPS15OTVIframeTracks")
@interface OTVIframeTracks : NSObject
@property (nonatomic, readonly) NSInteger bandwith;
@property (nonatomic, readonly) NSInteger averageBandwidth;
@property (nonatomic, readonly, copy) NSString * _Nullable uri;
@property (nonatomic, readonly, copy) NSString * _Nullable codecs;
@property (nonatomic, readonly) CGSize resolution;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// SSM session renewal mode
typedef SWIFT_ENUM_NAMED(NSInteger, OTVLicenseRenewType, "OTVLicenseRenewType", open) {
  OTVLicenseRenewTypeHeartbeat = 0,
  OTVLicenseRenewTypeEnforced = 1,
};

/// License request type
typedef SWIFT_ENUM_NAMED(NSInteger, OTVLicenseRequestType, "OTVLicenseRequestType", open) {
  OTVLicenseRequestTypeRequest = 0,
  OTVLicenseRequestTypeRenewal = 1,
};

@class OTVStreamInfo;
enum OTVMediaSelectionOptions : NSInteger;
@class OTVStreamDrmInfo;

/// The media information of the <code>OTVPersistenceAsset</code>
SWIFT_CLASS("_TtC9OPYSDKFPS12OTVMediaInfo")
@interface OTVMediaInfo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// The asset Duration
@property (nonatomic, readonly) double duration;
/// The selected bandwidth to download (Deprecated, please use selectedBitrate)
@property (nonatomic, readonly) double selectedBandwidth SWIFT_DEPRECATED_MSG("", "selectedBitrate");
/// Return the selected bitrate of the  download
@property (nonatomic, readonly) double selectedBitrate;
/// Return the  selected resolution of the download
@property (nonatomic, readonly) CGSize selectedResolution;
/// Return the estimated size of the selected download
@property (nonatomic, readonly) uint64_t selectedEstimateSize;
/// The selected video track to download.
/// Please set one of the values returned from <code>availableStreamInfo</code>
/// note:
///
/// <ul>
///   <li>
///     Set this value only before the download start, otherwise it has no effect.
///   </li>
/// </ul>
@property (nonatomic, strong) OTVStreamInfo * _Nullable selectedStreamInfo;
/// The AVMediaSelectionOption to be chosen for the asset being download. Either all (all trakcs) or defualt (default tracks)
@property (nonatomic) enum OTVMediaSelectionOptions mediaSelections;
/// The availble iFrame tracks for the media content
@property (nonatomic, readonly, copy) NSArray<OTVIframeTracks *> * _Nullable availableIFrameTracks;
/// The list of availble video tracks to download and the media info assosiated
@property (nonatomic, readonly, copy) NSArray<OTVStreamInfo *> * _Nullable availableStreamInfo;
@property (nonatomic, readonly, copy) NSArray<OTVStreamDrmInfo *> * _Nullable availableDrmInfo;
@end


typedef SWIFT_ENUM(NSInteger, OTVMediaSelectionOptions, open) {
/// Preferred media tracks assoiciated with the asset
  OTVMediaSelectionOptionsPerferred = 1,
/// All media tracks assoiciated with the asset
  OTVMediaSelectionOptionsAll = 2,
};


SWIFT_CLASS("_TtC9OPYSDKFPS14OTVMediaTracks")
@interface OTVMediaTracks : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable type;
@property (nonatomic, readonly, copy) NSString * _Nullable name;
@property (nonatomic, readonly, copy) NSString * _Nullable language;
@property (nonatomic, readonly, copy) NSString * _Nullable isDefault;
@property (nonatomic, readonly, copy) NSString * _Nullable autoSelect;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// The <code>OTVNetworkAnalytics</code> class provides access to playback and network statistics.
/// note:
/// Not all values will be available immediately due to being accumulated over time
SWIFT_CLASS("_TtC9OPYSDKFPS19OTVNetworkAnalytics")
@interface OTVNetworkAnalytics : NSObject
/// Network analytics related to adaptive streaming
@property (nonatomic, readonly, strong) id <AdaptiveStreaming> _Nonnull adaptiveStreaming;
/// Network analytics related to network usage
@property (nonatomic, readonly, strong) id <NetworkUsage> _Nonnull networkUsage;
/// Network analytics related to the content server
@property (nonatomic, readonly, strong) id <ContentServer> _Nonnull contentServer;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC9OPYSDKFPS22OTVOutputDeviceMonitor")
@interface OTVOutputDeviceMonitor : NSObject
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, OTVOutputDeviceType, open) {
/// Digital output consists of HDMI output from HDMI adapters.
/// These can be connected to iOS,iPadOS and tvOS devices.
  OTVOutputDeviceTypeDigital = 1,
/// Airplay output can be setup between an iOS/iPadOS device to a tvOS device.
  OTVOutputDeviceTypeAirplay = 2,
/// Screen recording can be activated by an iOS/iPadOS device by clicking the recording button from the control pannel.
  OTVOutputDeviceTypeRecording = 3,
/// mirroring output can be setup between an iOS/iPadOS device to a tvOS device.
  OTVOutputDeviceTypeMirroring = 4,
/// This is an unknown type of output.
  OTVOutputDeviceTypeUnknown = 5,
};


SWIFT_CLASS("_TtC9OPYSDKFPS21OTVPersistLicenseInfo")
@interface OTVPersistLicenseInfo : NSObject
/// The license duration in seconds
@property (nonatomic) int64_t duration;
/// The license Info passed from the token in the form of a JSON String.
@property (nonatomic, copy) NSString * _Nullable licenseInfomation;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

enum OTVPersistenceDRMType : NSInteger;
@protocol OTVAVURLAssetExtension;

/// Downloads are represented by the objects of the class <code>OTVPersistenceAsset</code>.
/// They have a <code>OTVDownloadState</code> to reflect their lifecycle.
SWIFT_CLASS("_TtC9OPYSDKFPS19OTVPersistenceAsset")
@interface OTVPersistenceAsset : NSObject
/// Unique identifier for the asset
@property (nonatomic, readonly, copy) NSString * _Nonnull uuid;
/// Title of the asset
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
/// URL of the asset
@property (nonatomic, readonly, copy) NSString * _Nonnull url;
/// Progress of the asset download
@property (nonatomic, readonly) double percentComplete;
/// Returns the error details of the failure.
/// <ul>
///   <li>
///     This field applies only if the <code>downloadError</code> is not  <code>.noError</code>, returns <code>nil</code> otherwise
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nullable error;
/// Returns the failure reason of the download.
/// <ul>
///   <li>
///     This field applies only if the state is <code>error</code>, returns <code>nil</code> otherwise
///   </li>
/// </ul>
@property (nonatomic, readonly) enum OTVDownloadError downloadError;
/// The asset ID
@property (nonatomic, readonly, copy) NSString * _Nullable identifier;
/// The total size downloaded for the downloaded/downloading asset in bytes
@property (nonatomic, readonly) uint64_t totalSizeDownloaded;
/// The DRM type of the asset
@property (nonatomic, readonly) enum OTVPersistenceDRMType drmMode;
/// The OTVMediaInfo for the asset
@property (nonatomic, readonly, strong) OTVMediaInfo * _Nullable mediaInfo;
/// The OTVPersistLicenseInfo for the asset
@property (nonatomic, readonly, strong) OTVPersistLicenseInfo * _Nullable licenseInfo;
- (void)renewLicenseWithDelegate:(id <OTVLicenseDelegate> _Nonnull)delegate options:(NSDictionary<NSString *, id> * _Nullable)options;
/// Setup FPS license delegate.
/// note:
///
/// <ul>
///   <li>
///     The <code>OTVPersistenceAsset</code> object MUST be in state `prepared, otherwise calling this function has no effect.
///   </li>
/// </ul>
/// <ul>
///   <li>
///     Parameters:
///     urlAssetExtension: An object implements protocol <code>OTVAVURLAssetExtension</code>, e.g. <code>OTVPRMAVURLAsset</code>
///   </li>
/// </ul>
- (void)setupFPSWith:(id <OTVLicenseDelegate> _Nonnull)delegate;
/// Setup PRM for a download <code>OTVPRMAVURLAsset</code>.
/// note:
///
/// <ul>
///   <li>
///     The <code>OTVPersistenceAsset</code> object MUST be in one state from <code>notDownloaded</code>, <code>prepared</code> or <code>preparing</code>, otherwise calling this function has no effect.
///   </li>
/// </ul>
/// <ul>
///   <li>
///     Parameters:
///     urlAssetExtension: An object implements protocol <code>OTVAVURLAssetExtension</code>
///   </li>
/// </ul>
- (void)setupPRMFor:(id <OTVAVURLAssetExtension> _Nonnull)urlAssetExtension;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



enum OTVDownloadState : NSInteger;

@interface OTVPersistenceAsset (SWIFT_EXTENSION(OPYSDKFPS))
/// Current state of the asset
@property (nonatomic, readonly) enum OTVDownloadState state;
@end


/// ObjectiveC compatible enumeration of the possible states of a persistence asset.
typedef SWIFT_ENUM_NAMED(NSInteger, OTVDownloadState, "OTVPersistenceAssetState", open) {
/// The initial state.
  OTVDownloadStateNotDownloaded = 0,
/// OTVPersistenceAsset is being prepared.
  OTVDownloadStatePreparing = 1,
/// OTVPersistenceAsset is prepared and ready to be downloaded.
  OTVDownloadStatePrepared = 2,
/// Download is in progress.
  OTVDownloadStateDownloading = 3,
/// Download has been paused.
  OTVDownloadStatePaused = 4,
/// Download has completed.
  OTVDownloadStateDownloaded = 5,
/// An error has occurred during attempt to download.
  OTVDownloadStateError = 6,
};

/// ObjectiveC compatible enumeration of the possible DRM types of a persistence asset.
typedef SWIFT_ENUM(NSInteger, OTVPersistenceDRMType, open) {
/// Asset is of DRM Type PRM
  OTVPersistenceDRMTypeFps = 1,
/// Asset is of DRM Type FPS
  OTVPersistenceDRMTypePrm = 2,
/// Asset is of unknown DRM
  OTVPersistenceDRMTypeUnKnownDrm = 100,
/// Asset is clear
  OTVPersistenceDRMTypeNoDrm = 200,
};

@class AVMediaSelection;

/// <code>OTVPersistenceManager</code> is a singleton that manages all download related functionality.
/// It utilises <code>OTVDownloadingAssetManager</code> for <em>outstanding</em> downloads and <code>OTVAssetsManager</code> for <em>completed</em> downloads.
SWIFT_CLASS("_TtC9OPYSDKFPS21OTVPersistenceManager")
@interface OTVPersistenceManager : NSObject
/// Persistence Manager singleton instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) OTVPersistenceManager * _Nonnull shared;)
+ (OTVPersistenceManager * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Start a media stream dowloading.
/// note:
/// You MUST NOT share the same license delegate instance for multiple downloading.
/// \param urlAsset Asset needs to be downloaded
///
/// \param title Stream’s title
///
/// \param licenseDelegate Delegate to fetch the license
///
/// \param artwork artwork Data
///
/// \param options download options
///
///
/// returns:
/// an asset created for this download.
- (OTVPersistenceAsset * _Nullable)startDownloadWithUrlAsset:(AVURLAsset * _Nonnull)urlAsset title:(NSString * _Nonnull)title licenseDelegate:(id <OTVLicenseDelegate> _Nullable)licenseDelegate artwork:(NSData * _Nullable)artwork options:(NSDictionary<NSString *, id> * _Nullable)options SWIFT_WARN_UNUSED_RESULT;
/// Start Preparing a media stream ready for dowloading.
/// note:
///
/// <ul>
///   <li>
///     To begin the download you must wait for the prepared download state on the OTVPersistenceAsset returned here.
///   </li>
///   <li>
///     Once the OTVPersistenceAsset has entered <code>prepared</code> state:
///     <ul>
///       <li>
///         You can check the mediaInfo values on the OTVPersistenceAsset
///       </li>
///       <li>
///         You can query the <code>OTVPersistenceAsset.mediaInfo.availableStreamInfo</code> to see all the information needed to start downloading the asset.
///       </li>
///       <li>
///         You can query the <code>OTVPersistenceAsset.mediaInfo.availableDrmInfo</code> to get the drm information of the asset.
///       </li>
///     </ul>
///   </li>
///   <li>
///     You SHOULD retain the object returned from preparedDownload, and pass the object to call startDownload: persistenceAsset… when state is changed to Prepared
///   </li>
/// </ul>
/// \param url Url of asset needs to be downloaded
///
/// \param title Stream’s title
///
///
/// returns:
/// an asset created for this download.
- (OTVPersistenceAsset * _Nonnull)prepareDownloadWithUrl:(NSURL * _Nonnull)url title:(NSString * _Nonnull)title SWIFT_WARN_UNUSED_RESULT;
/// Start a media stream dowloading for a <code>OTVPersistenceAsset</code>
/// note:
///
/// <ul>
///   <li>
///     You MUST call <code>prepareDownload</code> and wait for state <code>Prepared</code> on the <code>OTVPersistenceAsset</code> before calling this function
///     <ul>
///       <li>
///         If the stream is FPS encrypted, you MUST call <code>setupFPS:</code> on the prepared <code>OTVPersistenceAsset</code> before calling this function, and pass an <code>OTVLicenseDelegate</code> instance;
///       </li>
///       <li>
///         If the stream is PRM encrypted, you MUST call <code>setupPRM:</code> on the prepared <code>OTVPersistenceAsset</code> before call this function, and pass an <code>OTVPRMAVURLAsset</code> object;
///       </li>
///       <li>
///         If the stream is clear one, you SHOULD NOT call <code>setupFPS:</code> or <code>setupPRM:</code> on the prepared <code>OTVPersistenceAsset</code>.
///       </li>
///       <li>
///         You can set a number of values on the <code>OTVPersistenceAsset</code> to choose what resolution and bitrate you want to download
///       </li>
///       <li>
///         You can do this by setting <code>OTVPersistenceAsset.mediaInfo.selectedStreamInfo</code> from selection one of the <code>OTVPersistenceAsset.mediaInfo.availableStreamInfo</code>
///       </li>
///       <li>
///         If no value is set for <code>OTVPersistenceAsset.mediaInfo.selectedStreamInfo</code> we will check the <code>options</code> value passed into this function.
///       </li>
///       <li>
///         If neither of these values are set then we will use the highest possible value you are able to download.
///       </li>
///     </ul>
///   </li>
/// </ul>
/// \param asset an object of <code>OTVPersistenceAsset</code> in <code>prepared</code> state
///
/// \param artwork artwork Data
///
/// \param options download options
///
/// \param avMediaSelectionOptions the media selection to download, if it is not set, the default selection will be download
///
///
/// returns:
/// <code>True</code> if download start successful, <code>False</code> if there is some error, e.g. the <code>asset</code> is not in <code>prepared</code> state.
- (BOOL)startDownloadWithAsset:(OTVPersistenceAsset * _Nonnull)asset artwork:(NSData * _Nullable)artwork options:(NSDictionary<NSString *, id> * _Nullable)options avMediaSelectionOptions:(NSArray<AVMediaSelection *> * _Nullable)avMediaSelectionOptions SWIFT_WARN_UNUSED_RESULT;
/// Start a media stream dowloading for a <code>OTVPersistenceAsset</code>
/// note:
///
/// <ul>
///   <li>
///     You MUST call <code>prepareDownload</code> and wait for state <code>Prepared</code> on the <code>OTVPersistenceAsset</code> before calling this function
///     <ul>
///       <li>
///         If the stream is FPS encrypted, you MUST call <code>setupFPS:</code> on the prepared <code>OTVPersistenceAsset</code> before calling this function, and pass an <code>OTVLicenseDelegate</code> instance;
///       </li>
///       <li>
///         If the stream is PRM encrypted, you MUST call <code>setupPRM:</code> on the prepared <code>OTVPersistenceAsset</code> before call this function, and pass an <code>OTVPRMAVURLAsset</code> object;
///       </li>
///       <li>
///         If the stream is clear one, you SHOULD NOT call <code>setupFPS:</code> or <code>setupPRM:</code> on the prepared <code>OTVPersistenceAsset</code>.
///       </li>
///       <li>
///         You can set a number of values on the <code>OTVPersistenceAsset</code> to choose what resolution and bitrate you want to download
///       </li>
///       <li>
///         You can do this by setting <code>OTVPersistenceAsset.mediaInfo.selectedStreamInfo</code> from selection one of the <code>OTVPersistenceAsset.mediaInfo.availableStreamInfo</code>
///       </li>
///       <li>
///         If no value is set for <code>OTVPersistenceAsset.mediaInfo.selectedStreamInfo</code> we will check the <code>options</code> value passed into this function.
///       </li>
///       <li>
///         If neither of these values are set then we will use the highest possible value you are able to download.
///       </li>
///     </ul>
///   </li>
/// </ul>
/// \param asset an object of <code>OTVPersistenceAsset</code> in <code>prepared</code> state
///
/// \param artwork artwork Data
///
/// \param options download options
///
///
/// returns:
/// <code>True</code> if download start successful, <code>False</code> if there is some error, e.g. the <code>asset</code> is not in <code>prepared</code> state.
- (BOOL)startDownloadWithAsset:(OTVPersistenceAsset * _Nonnull)asset artwork:(NSData * _Nullable)artwork options:(NSDictionary<NSString *, id> * _Nullable)options SWIFT_WARN_UNUSED_RESULT;
/// Return downloading and downloaded assets.
- (NSArray<OTVPersistenceAsset *> * _Nullable)getDownloads SWIFT_WARN_UNUSED_RESULT;
/// Pause the downloading of assigned asset.
/// \param asset the asset to be paused.
///
- (BOOL)pauseDownloadWithAsset:(OTVPersistenceAsset * _Nonnull)asset SWIFT_WARN_UNUSED_RESULT;
/// Resume the paused downloading asset.
/// \param asset the asset to be resumed.
///
- (BOOL)resumeDownloadWithAsset:(OTVPersistenceAsset * _Nonnull)asset SWIFT_WARN_UNUSED_RESULT;
/// Cancel or remove the asset.
/// \param asset the asset to be cancelled or removed.
///
- (BOOL)deleteDownloadWithAsset:(OTVPersistenceAsset * _Nonnull)asset SWIFT_WARN_UNUSED_RESULT;
@end



@interface OTVPersistenceManager (SWIFT_EXTENSION(OPYSDKFPS))
- (int64_t)totalDiskSpaceInBytes SWIFT_WARN_UNUSED_RESULT;
- (int64_t)freeDiskSpaceInBytes SWIFT_WARN_UNUSED_RESULT;
- (int64_t)usedDiskSpaceInBytes SWIFT_WARN_UNUSED_RESULT;
@end

@protocol Player;
@protocol Rendering;

/// The <code>OTVPlaybackAnalytics</code> class provides access to playback and playback statistics.
SWIFT_CLASS("_TtC9OPYSDKFPS20OTVPlaybackAnalytics")
@interface OTVPlaybackAnalytics : NSObject
/// Playback analytics related to the player
@property (nonatomic, readonly, strong) id <Player> _Nonnull player;
/// Playback analytics related to the rendering
@property (nonatomic, readonly, strong) id <Rendering> _Nonnull rendering;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// :nodoc:
SWIFT_CLASS_NAMED("OTVSDKInternal")
@interface OTVSDK : NSObject
/// :nodoc:
+ (void)loadWithLicence:(NSString * _Nullable)licence;
/// :nodoc:
+ (void)setLoggingWithLevel:(OTVLogType)level;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// The OTVSSMLicenseResponse is a container class used to hold the full license response (license/ckc data, the heartbeat period and the renewal type)
SWIFT_CLASS("_TtC9OPYSDKFPS21OTVSSMLicenseResponse")
@interface OTVSSMLicenseResponse : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// <code>OTVSSPLicenseDelegate</code> is a default implementation of SSP with SSM Service.
SWIFT_CLASS("_TtC9OPYSDKFPS21OTVSSPLicenseDelegate")
@interface OTVSSPLicenseDelegate : OTVCommonLicenseDelegate
/// Set the type for the HTTP requesting headers
/// \param type String value of HTTP header type. Defaults to nv-authorizations. If an empty string is passed it was also default to nv-authorizations
///
- (void)setHTTPHeaderTypeWithType:(NSString * _Nonnull)type;
/// Creates an instance of <code>OTVSSPLicenceDelegate</code>.
/// \param certificateURL URL of certificate file.
///
/// \param licenseURL URL of license request.
///
/// \param ssmServerURL Optional URL of SSM service request. Default is nil if SSM service not required.
///
/// \param syncSSMSetupTeardown If ssmServerURL is provided this defines whether the setup and teardown network requests block the main thread or not. Default is to block.
///
- (nonnull instancetype)initWithCertificateURL:(NSURL * _Nonnull)certificateURL licenseURL:(NSURL * _Nonnull)licenseURL ssmServerURL:(NSURL * _Nullable)ssmServerURL syncSSMSetupTeardown:(BOOL)syncSSMSetupTeardown OBJC_DESIGNATED_INITIALIZER;
/// Creates an instance of <code>OTVSSPLicenceDelegate</code>.
/// \param certificateURL URL of certificate file.
///
/// \param licenseURL URL of license request.
///
/// \param ssmServerURL Optional URL of SSM service request.
///
- (nonnull instancetype)initWithCertificateURL:(NSURL * _Nonnull)certificateURL licenseURL:(NSURL * _Nonnull)licenseURL ssmServerURL:(NSURL * _Nullable)ssmServerURL;
/// Creates an instance of <code>OTVSSPLicenceDelegate</code>.
/// \param certificateURL URL of certificate file.
///
/// \param licenseURL URL of license request.
///
- (nonnull instancetype)initWithCertificateURL:(NSURL * _Nonnull)certificateURL licenseURL:(NSURL * _Nonnull)licenseURL;
- (NSDictionary<NSString *, NSString *> * _Nullable)generateHTTPHeadersWithAssetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
- (NSURL * _Nonnull)getLicenseRequestUrl SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)getCkcFromLicenseResponseWithResponse:(NSDictionary<NSString *, id> * _Nonnull)response SWIFT_WARN_UNUSED_RESULT;
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID session:(AVContentKeySession * _Nonnull)session keyRequest:(AVContentKeyRequest * _Nonnull)keyRequest SWIFT_WARN_UNUSED_RESULT;
/// Set the token and the url which associated with the stream.
/// note:
/// If repeated license request require a new media token please use setToken() as any repeated license request will use the original token set from this function.
/// \param token the stream’s SSP specific media token.
///
/// \param url URL of the stream.
///
/// \param success closure for when the stream token and url are sucessfully set. Default to empty.
///
/// \param failure closure for when the stream token and url fail to be set. Default to empty.
///
- (void)setStreamWithToken:(NSString * _Nonnull)token with:(NSURL * _Nonnull)url success:(void (^ _Nonnull)(void))success failure:(void (^ _Nonnull)(void))failure;
/// Application to set the initial stream token and callback which will be used by SDK to request for a new SSP content token, when a new license is requested.
/// note:
/// If repeated license requests do not need a new media token, please use setStream() as this function will request a new media token for each licnese request after the first.
/// \param initialToken The stream’s SSP specific media token to be used for the initial playback
///
/// \param tokenCallback Callback to be used to request the new media token. This callback is fired when a new licnese request is generated.
///
- (void)setTokenWithInitialToken:(NSString * _Nonnull)initialToken tokenCallback:(NSString * _Nonnull (^ _Nonnull)(void))tokenCallback;
@end


SWIFT_CLASS("_TtC9OPYSDKFPS16OTVStreamDrmInfo")
@interface OTVStreamDrmInfo : NSObject
/// The DRM type of the <code>OTVPersistenceAsset</code>
@property (nonatomic, readonly) enum OTVPersistenceDRMType drmType;
/// The DRM key information data from manifest
@property (nonatomic, readonly, copy) NSString * _Nonnull keyInfo;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// The stream information of the <code>OTVPersistenceAsset</code>
SWIFT_CLASS("_TtC9OPYSDKFPS13OTVStreamInfo")
@interface OTVStreamInfo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// The asset Duration
@property (nonatomic, readonly) double duration;
/// The bandwidth of the media content
@property (nonatomic, readonly) double bitrate;
/// The estimated size of the media content
@property (nonatomic) uint64_t totalSizeEstimate;
/// The Resolution of the media content
@property (nonatomic, readonly) CGSize resolution;
/// The codecs of the media content
@property (nonatomic, readonly, copy) NSString * _Nonnull codecs;
@end


/// This class can be used to display I-Frames from a stream, e.g. for display of thumbnails while seeking.
/// The <code>URL</code> provided to the initialiser must point to a HLS playlist with I-Frames, otherwise the <code>hasThumbnails</code> function will return <code>false</code> and the view won’t render thumbnails.
/// note:
/// <code>hasThumbnails</code> will return <code>false</code> immediately after initalisation, even for a playlist that has I-Frames. This is because the playlist needs to first be downloaded and checked for I-Frames.
SWIFT_CLASS("_TtC9OPYSDKFPS16OTVThumbnailView")
@interface OTVThumbnailView : UIView
/// Initialises the view with the specified stream URL and optional frame.
/// \param url the stream URL to receive I-Frames from
///
/// \param frame the frame to create the view with
///
- (nonnull instancetype)initWithUrl:(NSURL * _Nonnull)url frame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (void)layoutSubviews;
/// Specifies whether the <code>URL</code> provided to the initaliser points to a HLS playlist with I-Frames or not
- (BOOL)hasThumbnails SWIFT_WARN_UNUSED_RESULT;
/// Specifies which I-Frame the view should render
/// \param seconds The time within the stream for which to render the I-Frame
///
- (void)setTimeToSeconds:(NSTimeInterval)seconds;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end


/// Describes a track, e.g. subtitle or audio track
SWIFT_CLASS("_TtC9OPYSDKFPS12OTVTrackInfo")
@interface OTVTrackInfo : NSObject
/// The type of track
@property (nonatomic, readonly) enum OTVTrackType type;
/// The name of the track
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// The language code of the track
@property (nonatomic, readonly, copy) NSString * _Nullable language;
/// The media type of the track, one of audio, webvtt, cc, smpte_tt, srt, apic or unknown
@property (nonatomic, readonly, copy) NSString * _Nonnull mediaType;
/// The number of channels in the audio track
@property (nonatomic, readonly) NSInteger channelCount;
/// Enumeration of the codec of the track
@property (nonatomic, readonly) NSInteger codec;
/// The accessibility characteristics of the track
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull characteristics;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Defines the track types available on <code>OTVAVPlayer</code>
typedef SWIFT_ENUM(NSInteger, OTVTrackType, open) {
/// Audio tracks
  OTVTrackTypeAudio = 0,
/// Subtitle tracks
  OTVTrackTypeSubtitle = 1,
};


/// Protocol for listening to available tracks changing
SWIFT_PROTOCOL("_TtP9OPYSDKFPS24OTVTracksChangedListener_")
@protocol OTVTracksChangedListener
/// Called when the available tracks have changed
- (void)tracksChanged;
@end

@class AVPlayerLayer;

/// DEPRECATED: Integration Nexguard watermark support on iOS Platform.
/// This class is no longer in use and contains only no-op function stubs.
/// Please refer to the Quickmark documentation for new usage.
SWIFT_CLASS("_TtC9OPYSDKFPS12OTVWatermark")
@interface OTVWatermark : NSObject
/// Deprecated - This function is an empty stub and does nothing.
- (nullable instancetype)initWithSecret:(NSString * _Nonnull)secret OBJC_DESIGNATED_INITIALIZER;
/// Deprecated - This function is an empty stub and does nothing.
- (nullable instancetype)initWithUrl:(NSString * _Nonnull)url token:(NSString * _Nonnull)token tenant:(NSString * _Nonnull)tenant secret:(NSString * _Nonnull)secret OBJC_DESIGNATED_INITIALIZER;
/// Deprecated - This function is an empty stub and does nothing.
- (void)setWithToken:(NSString * _Nonnull)token;
/// Deprecated - This function is an empty stub and does nothing.
- (void)setWithUrl:(NSString * _Nonnull)url;
/// Deprecated - This function is an empty stub and does nothing.
- (void)setWithTenant:(NSString * _Nonnull)tenant;
/// Deprecated - This function is an empty stub and does nothing.
- (void)setWithApiKey:(NSString * _Nonnull)apiKey;
/// Deprecated - This function is an empty stub and does nothing.
@property (nonatomic, readonly, copy) NSString * _Nonnull quickmarkVersion;
/// Deprecated - This function is an empty stub and does nothing.
@property (nonatomic, readonly, copy) NSString * _Nullable quickmarkCoreVersion;
/// Deprecated - This function is an empty stub and does nothing.
- (void)bindWithPlayerView:(UIView * _Nonnull)playerView playerLayer:(AVPlayerLayer * _Nonnull)playerLayer;
/// Deprecated - This function is an empty stub and does nothing
- (void)unbind;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Playback analytics related to the player
SWIFT_PROTOCOL("_TtP9OPYSDKFPS6Player_")
@protocol Player
/// Returns the total amount of buffered content, in seconds.
///
/// returns:
/// the total amount of buffered content, in seconds
- (double)bufferedDuration SWIFT_WARN_UNUSED_RESULT;
/// Returns an array of resoloutions available in the playlist
/// note:
/// This function will make a seperate request for the Master playlist to return all the availableresoloutions. This request is only done once you call this function and only on the first time you call it for that contnet. Every subsiquent call on the same content does not requst the playlist again.
///
/// returns:
/// an array of resoloutions available in the playlist, or nil if unknown
- (NSArray<NSValue *> * _Nullable)availableResoloutions SWIFT_WARN_UNUSED_RESULT;
/// Returns the resoloution of the content being played
///
/// returns:
/// the Resoloution of the content being played as a  CGSzie e.g CGSize(width: 1920, height: 1080) or CGSizeZero if Uknown or Audio only.
- (CGSize)selectedResoloution SWIFT_WARN_UNUSED_RESULT;
/// Returns the accumulated duration, in seconds, until the player item is ready to play.
///
/// returns:
/// the accumulated duration, in seconds, until the player item is ready to play or -1 if uknown
- (double)startUpTime SWIFT_WARN_UNUSED_RESULT;
/// Returns the total number of playback stalls encountered.
///
/// returns:
/// total number of playback stalls encountered.
- (NSInteger)numberOfStalls SWIFT_WARN_UNUSED_RESULT;
/// Returns the playback type can be live, VOD, or from a file. If nil is returned the playback type is unknown.
///
/// returns:
/// the playback type can be live, VOD, or from a file. If nil is returned the playback type is unknown.
- (NSString * _Nullable)playbackType SWIFT_WARN_UNUSED_RESULT;
/// Returns the date and time at which playback began for this event.
///
/// returns:
/// the date and time at which playback began for this event.
- (NSDate * _Nullable)playbackStartDate SWIFT_WARN_UNUSED_RESULT;
/// Returns the offset, in seconds, in the playlist where the last uninterrupted period of playback began.
///
/// returns:
/// the offset, in seconds, in the playlist where the last uninterrupted period of playback began.
- (NSTimeInterval)playbackStartOffset SWIFT_WARN_UNUSED_RESULT;
@end


/// Playback analytics related to the player
SWIFT_PROTOCOL("_TtP9OPYSDKFPS9Rendering_")
@protocol Rendering
/// Returns the total number of dropped video frames
///
/// returns:
/// the total number of dropped video frames
- (NSInteger)frameDrops SWIFT_WARN_UNUSED_RESULT;
/// Returns the total number of dropped dived by the length of watched content
///
/// returns:
/// the total number of dropped dived by the length of watched content
- (NSInteger)frameDropsPerSecond SWIFT_WARN_UNUSED_RESULT;
/// Returns the frame rate of the current content as measured during playback.
///
/// returns:
/// the frame rate of the current content as measured during playback.
- (NSInteger)framesPerSecond SWIFT_WARN_UNUSED_RESULT;
/// Returns the frame rate of the current content as announced in the stream.
/// note:
/// This function will make a seperate request for the Master playlist to return all the stream information. This request is only done once you call this function and only on the first time you call it for that contnet. Every subsiquent call on the same content does not requst the playlist again.
///
/// returns:
/// the frame rate of the current content as announced in the stream.
- (NSInteger)framesPerSecondNominal SWIFT_WARN_UNUSED_RESULT;
@end


#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
#ifndef OPYSDKFPS_SWIFT_H
#define OPYSDKFPS_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import AVFoundation;
@import CoreFoundation;
@import CoreMedia;
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#import <OPYSDKFPS/OPYSDKFPS.h>

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="OPYSDKFPS",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)



/// Network analytics related to adaptive streaming
SWIFT_PROTOCOL("_TtP9OPYSDKFPS17AdaptiveStreaming_")
@protocol AdaptiveStreaming
/// Returns an array of bitrates available in the playlist
/// note:
/// This function will make a seperate request for the Master playlist to return all the availableBitrates. This request is only done once you call this function and only on the first time you call it for that contnet. Every subsiquent call on the same content does not requst the playlist again.
///
/// returns:
/// an array of bitrates available in the playlist, or nil if unknown
- (NSArray<NSNumber *> * _Nullable)availableBitrates SWIFT_WARN_UNUSED_RESULT;
/// Returns the bitrate from the playlist that has been selected for playback, in bits per second
///
/// returns:
/// the bitrate from the playlist that has been selected for playback, or 0 if unknown
- (double)selectedBitrate SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of times the bitrate has switched.
///
/// returns:
/// the number of times the bitrate has switched.
- (NSInteger)bitrateSwitches SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of times the bitrate has switched to a lower bitrate.
///
/// returns:
/// the number of times the bitrate has switched to a lower bitrate.
- (NSInteger)bitrateDowngrade SWIFT_WARN_UNUSED_RESULT;
/// Returns the Video and Audio track’s average bit rate, in bits per second.
///
/// returns:
/// the Video and Audio track’s average bit rate, in bits per second.
- (NSInteger)averageBitrate SWIFT_WARN_UNUSED_RESULT;
/// Returns the video track’s average bit rate, in bits per second.
///
/// returns:
/// the  video track’s average bit rate, in bits per second.
- (NSInteger)averageVideoBitrate SWIFT_WARN_UNUSED_RESULT;
/// Returns the audio track’s average bit rate, in bits per second.
///
/// returns:
/// the  audio track’s average bit rate, in bits per second.
- (NSInteger)averageAudioBitrate SWIFT_WARN_UNUSED_RESULT;
@end


/// Entry point for the Thumbnail on Seek functionality
SWIFT_CLASS("_TtC9OPYSDKFPS15AssetThumbnails")
@interface AssetThumbnails : NSObject
/// Default constructor used to build the <code>AssetThumbnail</code> class
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSString;

/// Network analytics related to the content server
SWIFT_PROTOCOL("_TtP9OPYSDKFPS13ContentServer_")
@protocol ContentServer
/// Returns the IP address of the content server
///
/// returns:
/// the IP address of the content server for the last segment, or nil if unknown
- (NSString * _Nullable)finalIPAddress SWIFT_WARN_UNUSED_RESULT;
/// Returns the URL of the selected playlist, after any redirects
///
/// returns:
/// the URL of the selected playlist, or nil if unknown
- (NSString * _Nullable)finalURL SWIFT_WARN_UNUSED_RESULT;
/// Returns the original URL of the stream
///
/// returns:
/// the original URL of the stream, or nil if unknown
- (NSString * _Nullable)url SWIFT_WARN_UNUSED_RESULT;
/// Returns a count of changes to the server address over the last uninterrupted period of playback.
///
/// returns:
/// the number of server address changes or -1 if unknown
- (NSInteger)numberOfServerAddressChanges SWIFT_WARN_UNUSED_RESULT;
@end





/// The <code>IOTVLogProvider</code> protocol defines a method that allows application to receive the log message from SDK in production build.
SWIFT_PROTOCOL("_TtP9OPYSDKFPS15IOTVLogProvider_")
@protocol IOTVLogProvider <NSObject>
/// This method is used by SDK to pass the log message to application.
/// \param xLog log message
///
- (void)logProviderWithXLog:(NSString * _Nonnull)xLog;
@end



/// Network analytics related to network usage
SWIFT_PROTOCOL("_TtP9OPYSDKFPS12NetworkUsage_")
@protocol NetworkUsage
/// Returns the number of bytes downloaded so far
///
/// returns:
/// the number of bytes downloaded so far
- (int64_t)bytesDownloaded SWIFT_WARN_UNUSED_RESULT;
/// Returns the empirical throughput, in bits per second, across all media downloaded
///
/// returns:
/// the throughput, in bits per second
- (double)downloadBitrate SWIFT_WARN_UNUSED_RESULT;
/// Returns the video track’s average bit rate, in bits per second
///
/// returns:
/// the video track’s average bit rate, in bits per second
- (double)downloadBitrateAverage SWIFT_WARN_UNUSED_RESULT;
/// Returns the number of media read requests from the server to this client
///
/// returns:
/// The number of media read requests from the server to this client or -1 if unknown
- (NSInteger)numberOfMediaRequests SWIFT_WARN_UNUSED_RESULT;
/// Returns the accumulated duration, in seconds, of active network transfer of bytes
///
/// returns:
/// the accumulated duration, in seconds, of active network transfer of bytes or -1 if unknown
- (NSTimeInterval)transferDuration SWIFT_WARN_UNUSED_RESULT;
/// Returns the total number of times that downloading the segments took too long.
///
/// returns:
/// the total number of times that downloading the segments took too long or -1 if unknown
- (NSInteger)downloadsOverdue SWIFT_WARN_UNUSED_RESULT;
@end

@class OTVNetworkAnalytics;
@class OTVPlaybackAnalytics;
@class UIView;
@class AVPlayerItem;
@class NSURL;
enum OTVTrackType : NSInteger;
@class OTVTrackInfo;
@protocol OTVTracksChangedListener;

SWIFT_CLASS("_TtC9OPYSDKFPS11OTVAVPlayer")
@interface OTVAVPlayer : AVPlayer
/// Network analytics for the player
@property (nonatomic, readonly, strong) OTVNetworkAnalytics * _Nullable networkAnalytics;
/// Playback analytics for the player
@property (nonatomic, readonly, strong) OTVPlaybackAnalytics * _Nullable playbackAnalytics;
/// A view for rendering non-native subtitles to. This view should be at least as large as the relevant AVPlayerLayer.videoRect, but no wider.
@property (nonatomic, strong) UIView * _Nullable subtitleView;
/// :nodoc:
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Private init with AVPlayerItem which should not be called outside. Creates an instance of <code>OTVAVPlayer</code> using an <code>AVPlayerItem</code>.
/// Make sure the item is initialized with OTVAVPlayerItem, otherwise a fatal error will be raised.
/// \param item <code>AVPlayerItem</code> item to be played.
///
- (nonnull instancetype)initWithPlayerItem:(AVPlayerItem * _Nullable)item OBJC_DESIGNATED_INITIALIZER;
/// Creates an instance of <code>OTVAVPlayer</code> using a URL.
/// note:
/// Calling this function before loading the <code>OTVSDK</code> (with <code>OTVSDK.load()</code> or <code>OTVSDK.load(licence)</code>) will result in a playback error.
/// \param URL URL of the content to be played.
///
- (nonnull instancetype)initWithURL:(NSURL * _Nonnull)URL;
/// Replaces the current item being played with another <code>AVPlayerItem</code>.
/// note:
/// the item should be an <code>OTVAVPlayerItem</code>, otherwise it will be ignored.
/// \param item <code>AVPlayerItem</code> to be played.
///
- (void)replaceCurrentItemWithPlayerItem:(AVPlayerItem * _Nullable)item;
/// :nodoc:
- (void)play;
/// :nodoc:
- (void)playImmediatelyAtRate:(float)rate;
/// Returns an array of tracks available for the specified type.
/// \param type The type of tracks to return
///
- (NSArray<OTVTrackInfo *> * _Nonnull)tracksWithType:(enum OTVTrackType)type SWIFT_WARN_UNUSED_RESULT;
/// Returns the selected track index for the specified type, or -1 if nothing is selected.
/// \param type The type of track to return
///
- (NSInteger)selectedTrackWithType:(enum OTVTrackType)type SWIFT_WARN_UNUSED_RESULT;
/// Selects the specified track
/// \param type The type of the track to select
///
/// \param index The index of the track to select
///
- (void)selectTrackWithType:(enum OTVTrackType)type index:(NSInteger)index;
/// Deselects the specified track.
/// \param type The type of the track to deselect
///
/// \param index The index of the track to deselect
///
- (void)deselectTrackWithType:(enum OTVTrackType)type index:(NSInteger)index;
/// Registers a listener for when the tracks available change.
/// The listener may be called at any point during playback.
/// \param tracksChangedListener The listener
///
- (void)registerWithTracksChangedListener:(id <OTVTracksChangedListener> _Nonnull)tracksChangedListener;
/// Unregisters a listener for when the tracks available change
/// \param tracksChangedListener The listener
///
- (void)unregisterWithTracksChangedListener:(id <OTVTracksChangedListener> _Nonnull)tracksChangedListener;
/// Add an external SRT subttile from a given URL
/// \param subtitleURL The URL of the subtitle
///
/// \param mimeType The mimeType of the subtitle
///
/// \param language The Language of the subtitle
///
- (void)addSubtitleWithUrl:(NSString * _Nonnull)subtitleURL mimeType:(NSString * _Nonnull)mimeType language:(NSString * _Nonnull)language;
@end


@class AVAsset;

/// <code>OTVAVPlayerItem</code> is derived from <code>AVPlayerItem</code>, please refer to apple’s documentation for further information.
SWIFT_CLASS("_TtC9OPYSDKFPS15OTVAVPlayerItem")
@interface OTVAVPlayerItem : AVPlayerItem
/// The content of HLS playlist. It’s a key path can be observed.
@property (nonatomic, copy) NSString * _Nonnull metadata;
/// Creates an instance of <code>OTVAVPlayerItem</code>.
/// \param asset an instance of <code>OTVAVURLAsset</code>
///
/// \param automaticallyLoadedAssetKeys An array of strings, each representing a property defined by <code>AVAsset</code>
///
- (nonnull instancetype)initWithAsset:(AVAsset * _Nonnull)asset automaticallyLoadedAssetKeys:(NSArray<NSString *> * _Nullable)automaticallyLoadedAssetKeys SWIFT_UNAVAILABLE;
/// Creates an instance of <code>OTVAVPlayerItem</code>.
/// \param asset an AVAsset, Must be <code>OTVAVURLAsset</code>, otherwise get <code>fatalError</code>
///
- (nonnull instancetype)initWithAsset:(AVAsset * _Nonnull)asset;
/// Creates an instance of <code>OTVAVPlayerItem</code>.
/// \param URL a URL.
///
- (nonnull instancetype)initWithURL:(NSURL * _Nonnull)URL;
@end

@class NSDate;

@interface OTVAVPlayerItem (SWIFT_EXTENSION(OPYSDKFPS))
- (void)seekToTime:(CMTime)time toleranceBefore:(CMTime)toleranceBefore toleranceAfter:(CMTime)toleranceAfter completionHandler:(void (^ _Nullable)(BOOL))completionHandler;
- (BOOL)seekToDate:(NSDate * _Nonnull)date completionHandler:(void (^ _Nullable)(BOOL))completionHandler SWIFT_WARN_UNUSED_RESULT;
@end


/// <code>OTVAVURLAsset</code> is used for streams encrypted with Apple’s FairPlay Streaming (FPS).
/// It is derived from <code>AVURLAsset</code>, please refer to apple’s documentation for further information.
SWIFT_CLASS("_TtC9OPYSDKFPS13OTVAVURLAsset")
@interface OTVAVURLAsset : AVURLAsset
/// Initializes an instance of <code>OTVAVURLAsset</code> for inspection of a media resource.
/// \param URL An instance of <code>NSURL</code> that references a media resource.
///
/// \param options An instance of <code>NSDictionary</code> that contains keys for specifying options for the initialization of the <code>OTVAVURLAsset</code>. See <code>AVURLAssetPreferPreciseDurationAndTimingKey</code> and <code>AVURLAssetReferenceRestrictionsKey</code>.
///
///
/// returns:
/// An instance of <code>AVURLAsset</code>.
- (nonnull instancetype)initWithURL:(NSURL * _Nonnull)URL options:(NSDictionary<NSString *, id> * _Nullable)options OBJC_DESIGNATED_INITIALIZER;
@end

@class NSData;
@class AVContentKeySession;
@class AVContentKeyRequest;

/// The <code>OTVLicenseDelegate</code> protocol defines methods that allows your code to handle the FPS request while playing a <em>FairPlay</em> encrypted stream.
SWIFT_PROTOCOL("_TtP9OPYSDKFPS18OTVLicenseDelegate_")
@protocol OTVLicenseDelegate <NSObject>
/// Returns the scheme that the integrator uses in the <code>EXT-X-KEY</code> URI.
///
/// returns:
/// String: Of Scheme.
- (NSString * _Nullable)scheme SWIFT_WARN_UNUSED_RESULT;
/// Returns the content identifier that the integrator uses in the server side.
/// \param url URL
/// The URL is the <code>EXT-X-KEY</code> URI, which may contain the information about the content identifier.
/// (The integrator decides what this parameter contains.)
///
///
/// returns:
/// Data contains the content identifier.
- (NSData * _Nullable)contentIdentifierWithUrl:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Returns the certificate that integrator uses in the server side.
///
/// returns:
/// Data contains the certificate.
- (NSData * _Nullable)certificate SWIFT_WARN_UNUSED_RESULT;
/// Returns the Content Key Context (CKC) message from the server side that is used to decrypt the FairPlay stream.
/// remark:
///
/// This delegate function only supports one asset playout. Customers should implement the <code>ckcMessageWithID(spc:assetID:)</code> when playback multistream in concurrency.
/// seealso:
/// <code>ckcMessageWithID(spc:assetID:)</code>, <code>ckcMessageWith(spc:assetID:session:keyRequest:)</code>
/// \param spc Data The Server Playback Context (SPC) is the payload produced from AVFoundation.
///
///
/// returns:
/// Data contains the Content Key Context (CKC) message.
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc SWIFT_WARN_UNUSED_RESULT;
/// Returns the Content Key Context (CKC) message from the server side that is used to decrypt the FairPlay stream.
/// \param spc Data The Server Playback Context (SPC) is the payload produced from AVFoundation.
///
/// \param assetID contentID from HLS Playlist. Multi playback should depend on the value to request different license.
///
///
/// returns:
/// Data contains the Content Key Context (CKC) message.
- (NSData * _Nullable)ckcMessageWithIDWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
/// Returns the Content Key Context (CKC) message from the server side that is used to decrypt the FairPlay stream.
/// remark:
///
/// In deployments where Secure Session Management is enforced by a short duration FPS license (“license-renew”),
/// the session and keyRequest values may be saved and later used to trigger renewal of the expiring license using:
/// <code>keySession.renewExpiringResponseData(for: keyRequest)</code>
/// \param spc Data The Server Playback Context (SPC) is the payload produced from AVFoundation.
///
/// \param assetID contentID from HLS Playlist. Multi playback should depend on the value to request different license.
///
/// \param session the AVContentKeySession for which the CKC is required
///
/// \param keyRequest the originating AVContentKeyRequest
///
///
/// returns:
/// Data contains the Content Key Context (CKC) message.
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID session:(AVContentKeySession * _Nonnull)session keyRequest:(AVContentKeyRequest * _Nonnull)keyRequest SWIFT_WARN_UNUSED_RESULT;
@end


/// <code>OTVCommonLicenceDelegate</code> is a default implementation of <code>OTVLicenseDelegate</code>.
SWIFT_CLASS("_TtC9OPYSDKFPS24OTVCommonLicenseDelegate")
@interface OTVCommonLicenseDelegate : NSObject <OTVLicenseDelegate>
/// Creates an instance of <code>OTVCommonLicenceDelegate</code>.
/// \param certificateURL URL of certificate file.
///
/// \param licenseURL URL of license request.
///
- (nonnull instancetype)initWithCertificateURL:(NSURL * _Nonnull)certificateURL licenseURL:(NSURL * _Nonnull)licenseURL OBJC_DESIGNATED_INITIALIZER;
/// Returns scheme for fairplay “skd”. This function can be override for mutltidrm. More in <code>OTVLicenseDelegate</code>.
- (NSString * _Nullable)scheme SWIFT_WARN_UNUSED_RESULT;
/// Returns the content identifier. This function can be override for mutltidrm. More in <code>OTVLicenseDelegate</code>.
- (NSData * _Nullable)contentIdentifierWithUrl:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Returns the certificate. This function can be override for mutltidrm. More in <code>OTVLicenseDelegate</code>.
- (NSData * _Nullable)certificate SWIFT_WARN_UNUSED_RESULT;
/// Returns the Content Key Context (CKC) message.
/// This function can be override for mutltidrm. More in <code>OTVLicenseDelegate</code>.
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc SWIFT_WARN_UNUSED_RESULT;
/// Returns the Content Key Context (CKC) message.
/// This function can be override for mutltidrm. More in <code>OTVLicenseDelegate</code>.
- (NSData * _Nullable)ckcMessageWithIDWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID session:(AVContentKeySession * _Nonnull)session keyRequest:(AVContentKeyRequest * _Nonnull)keyRequest SWIFT_WARN_UNUSED_RESULT;
/// Returns the license HTTP Request custom headers.
/// This function must be overridden for multidrm.
/// Default returns empty Dictionary. If a nil Dictionary is returned the licence request is not sent.
/// \param assetID client should use passed assetID to generate correctly http headers.
///
- (NSDictionary<NSString *, NSString *> * _Nullable)generateHTTPHeadersWithAssetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
- (NSURL * _Nonnull)getLicenseRequestUrl SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)getCkcFromLicenseResponseWithResponse:(NSDictionary<NSString *, id> * _Nonnull)response SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSCoder;

/// A container view that creates an <code>AVPlayerLayer</code> and subtitle view,
/// managing the interactions with <code>OTVAVPlayer</code> for easy integration.
/// Optionally custom overlays can be added on top of the video/subtitle content
/// through the ‘customOverlayView’ property. These views will sit below any optionally
/// bound <code>OTVWatermark</code>.
/// Any subviews added in storyboard or interface builder will be automatically moved
/// onto the customOverlayView. Note that this process recreates any auto layout constraints
/// so any constraints connected to an IBOutlet will be lost.
SWIFT_CLASS("_TtC9OPYSDKFPS16OTVContainerView")
@interface OTVContainerView : UIView
/// :nodoc:
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
/// :nodoc:
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
/// This function has no effect. Instead you should add your views to the customOverlayView property
- (void)addSubview:(UIView * _Nonnull)view;
/// This function has no effect. Instead you should add your views to the customOverlayView property
- (void)insertSubview:(UIView * _Nonnull)view atIndex:(NSInteger)index;
/// This function has no effect. Instead you should add your views to the customOverlayView property
- (void)insertSubview:(UIView * _Nonnull)view aboveSubview:(UIView * _Nonnull)siblingSubview;
/// This function has no effect. Instead you should add your views to the customOverlayView property
- (void)insertSubview:(UIView * _Nonnull)view belowSubview:(UIView * _Nonnull)siblingSubview;
/// This function has no effect. Reordering of views is not permitted, you may want to make use of the customOverlayView property
- (void)bringSubviewToFront:(UIView * _Nonnull)view;
/// This function has no effect. Reordering of views is not permitted, you may want to make use of the customOverlayView property
- (void)sendSubviewToBack:(UIView * _Nonnull)view;
/// This function has no effect. Reordering of views is not permitted, you may want to make use of the customOverlayView property
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;
@end

enum OTVLicenseRequestType : NSInteger;
@class OTVSSMLicenseResponse;

/// The OTVCustomerSSMCallback protocol imposes a requirement for the license and heartbeat functions.
/// An instance using this protocol would then be used by OTVCustomerSSMDelegate to provide the necessary protocol functionality.
SWIFT_PROTOCOL("_TtP9OPYSDKFPS22OTVCustomerSSMCallback_")
@protocol OTVCustomerSSMCallback <NSObject>
/// Returns the license continaining Content Key Context (CKC) message, and heartbeat period.
/// \param keySystem String corresponding to the desired key system (Fairplay for iOS)
///
/// \param payload token for license retrieval
///
/// \param licenseType “license-request” (inital) or “license-renew” (subsequent periodic renewal)
///
///
/// returns:
/// OTVSSMLicenseResponse containing the license data and the heartbeat period.
- (OTVSSMLicenseResponse * _Nonnull)licenseWithKeySystem:(NSString * _Nonnull)keySystem payload:(NSData * _Nonnull)payload licenseType:(enum OTVLicenseRequestType)licenseType SWIFT_WARN_UNUSED_RESULT;
/// Calls the application supplied heartbeat function
- (void)heartbeat;
@end


/// The OTVCustomerSSMDelegate class provides default implemetation to conform to the <code>OTVLicenseDelegate</code> protocol.
/// When a license is requested, it will use the license callback from the <code>OTVCustomerSSMCallback</code> conforming delegate, expecting
/// a response <code>OTVSSMLicenseResponse</code> containing the license data and a heartbeat period in seconds.
/// On receipt of a non-zero positive heartbeat period the first license request will start the heartbeat, starting at 0+heartbeat seconds.
/// It is the respoisibility of the calling application to stop the heartbeat when required by calling the ‘reset’ function.
SWIFT_CLASS("_TtC9OPYSDKFPS22OTVCustomerSSMDelegate")
@interface OTVCustomerSSMDelegate : NSObject <OTVLicenseDelegate>
/// Returns the certificate that integrator uses in the server side.
- (NSData * _Nullable)certificate SWIFT_WARN_UNUSED_RESULT;
/// Returns the scheme that the integrator uses in the <code>EXT-X-KEY</code> URI.
- (NSString * _Nullable)scheme SWIFT_WARN_UNUSED_RESULT;
/// Returns the content identifier that the integrator uses in the server side.
- (NSData * _Nullable)contentIdentifierWithUrl:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// ckcMessage is part of the <code>OTVLicenseDelegate</code> protocol
/// Here we use it to call the license callback supplied by the calling application and, if sucessful, to also start the heartbeat, calling the supplied heartbeat callback
/// \param spc payload passed to the external license request callback
///
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (NSData * _Nullable)ckcMessageWithIDWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
/// :nodoc:
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID session:(AVContentKeySession * _Nonnull)session keyRequest:(AVContentKeyRequest * _Nonnull)keyRequest SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class OTVDRMInfo;

SWIFT_CLASS("_TtC9OPYSDKFPS6OTVDRM")
@interface OTVDRM : NSObject
/// The shared <code>OTVDRMInfo</code> instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) OTVDRM * _Nonnull shared;)
+ (OTVDRM * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// Returns the DRMInfo supported for the device.
///
/// returns:
/// An array of OTVDRMInfo objects for the users device.
- (NSArray<OTVDRMInfo *> * _Nonnull)getDRMInfo SWIFT_WARN_UNUSED_RESULT;
/// Returns the OTVDRMInfo support of the contentType passed in.
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     drmName: Name of the Drm, the only support DRM on iOS FPS is com.apple.fps
///   </li>
///   <li>
///     mediaType: Not needed for this platform, just pass an empty string.
///   </li>
///   <li>
///     contentType: The contentType used for the detection: “MIMEType;codecs=hvc1” && “MIMEType;codecs=avc1 are the only two supported in this call”
///   </li>
/// </ul>
///
/// returns:
/// An array of OTVDRMInfo objects for the users device based on if the contentType passed is supported and the security level of that support.
- (NSArray<OTVDRMInfo *> * _Nonnull)getDRMInfoWithDrmName:(NSString * _Nonnull)drmName mediaType:(NSString * _Nonnull)mediaType contentType:(NSString * _Nonnull)contentType SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

enum OTVDRMSecurityLevel : NSInteger;

/// OTVDrmInfo class represents the capability and security level for a DRM key system and content type
/// Currently the only two supported Codecs for this class are AVC1 and HVC1
/// HVC1 codec is only supported on devices newer then iOS 11 and depending on the devices the DRM security level will differ between otvDRMSLHWDecode & otvDRMSLSW.
/// If a device is older than iOS 11 this api will return a nil OTVDRMInfo object inside of the array for HVC1 codecs.
SWIFT_CLASS("_TtC9OPYSDKFPS10OTVDRMInfo")
@interface OTVDRMInfo : NSObject
/// Name of the Drm, the only support DRM on iOS FPS is com.apple.fps
@property (nonatomic, readonly, copy) NSString * _Nullable name;
/// The contentType used for the detection: “MIMEType;codecs=hvc1” && “MIMEType;codecs=avc1” are the only two supported in this call
@property (nonatomic, readonly, copy) NSString * _Nullable contentType;
/// The security level detected from Drm
@property (nonatomic, readonly) enum OTVDRMSecurityLevel securityLevel;
@property (nonatomic, readonly, copy) NSString * _Nonnull securityLevelName;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// OTVDrmSecurityLevel represents the rated security for the different codecs
typedef SWIFT_ENUM(NSInteger, OTVDRMSecurityLevel, open) {
  OTVDRMSecurityLevelOtvDRMSLUknown = 0,
  OTVDRMSecurityLevelOtvDRMSLSW = 1,
  OTVDRMSecurityLevelOtvDRMSLHWCrypt = 2,
  OTVDRMSecurityLevelOtvDRMSLHWDecode = 3,
};


/// The <code>OTVDRMManager</code> class sets up an instance of DRM based upon <code>OTVLicenseDelegate</code>.
SWIFT_CLASS("_TtC9OPYSDKFPS13OTVDRMManager")
@interface OTVDRMManager : NSObject
/// The shared <code>OTVDRMManager</code> instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) OTVDRMManager * _Nonnull shared;)
+ (OTVDRMManager * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Set the license delegate for <code>OTVDRMManager</code> based on <code>OTVLicenseDelegate</code>.
/// note:
/// The delegate is held using a zeroing-weak reference, so it has a value of nil after it has been deallocated outside. Ensure the delegate is retained until it is no longer needed by player.
/// \param delegate An instance of <code>OTVLicenseDelegate</code>.
///
- (void)setLicenseDelegate:(id <OTVLicenseDelegate> _Nonnull)delegate;
- (void)requestLicenseWithIdentifier:(NSString * _Nonnull)identifier license:(NSDictionary<NSString *, id> * _Nullable)options;
/// Check is license is persisted
/// This function is called to determing if a license is persisted or not.
/// \param identifier license identifier.  Usually comes from playlist.  For <em>FairPlay</em>, it should be <code>skd://.....</code>
///
///
/// returns:
/// <code>true</code> - the license exists or <code>false</code> - the license does not exist.
- (BOOL)isLicensePersistedWithIdentifier:(NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
/// Erase the license persistence on the local storage.
/// \param identifier license identifier. same format when used in <code>requestLicense</code>.
///
///
/// returns:
/// <code>true</code> - the license has successfully been erased from local system.
/// <code>false</code> - the license does not exist.
- (BOOL)eraseOfflineLicenseWithIdentifier:(NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
- (void)renewLicenseWithIdentifier:(NSString * _Nonnull)identifier license:(NSDictionary<NSString *, id> * _Nullable)options;
@end



/// <code>OTVDefaultLicenseDelegate</code> is a default implementataion of License request class.
SWIFT_CLASS("_TtC9OPYSDKFPS25OTVDefaultLicenseDelegate")
@interface OTVDefaultLicenseDelegate : OTVCommonLicenseDelegate
/// Set license HTTP requesting headers
/// \param parameters dictionary of HTTP request headers
///
- (void)setHTTPHeaderWithParameters:(NSDictionary<NSString *, NSString *> * _Nonnull)parameters;
/// Overrided function to pass setted HTTP header for license request. It just return setted http header by call setHTTPHeader
/// remark:
///
/// <code>OTVDefaultLicenseDelegate</code> only support one playback instance. If you want to support multiple playback, inheret from <code>OTVCommonLicenseDelegate</code>, override the same function to generate different HTTP header based on assetID
- (NSDictionary<NSString *, NSString *> * _Nullable)generateHTTPHeadersWithAssetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithCertificateURL:(NSURL * _Nonnull)certificateURL licenseURL:(NSURL * _Nonnull)licenseURL OBJC_DESIGNATED_INITIALIZER;
@end

/// ObjectiveC compatible enumeration of the possible errors of a persistence asset.
typedef SWIFT_ENUM(NSInteger, OTVDownloadError, open) {
/// No error
  OTVDownloadErrorNoError = 0,
/// An unknown or unexpected error occured.
  OTVDownloadErrorUnknownError = 1,
/// An error happens in download task
  OTVDownloadErrorDownloadTaskError = 2,
/// An error happends when requesting the license
  OTVDownloadErrorLicenseRequestError = 3,
/// An error happends when downloading the manifest
  OTVDownloadErrorManifestDownloadError = 4,
/// An error happends when parsing the manifest
  OTVDownloadErrorManifestParseError = 5,
/// An error indicates downloading a  LIVE content is not supported
  OTVDownloadErrorUnsupportedLiveError = 6,
/// An error indicates there is not enough space on device
  OTVDownloadErrorInsufficientSpaceError = 7,
};


/// An instance of a player event
SWIFT_CLASS("_TtC9OPYSDKFPS8OTVEvent")
@interface OTVEvent : NSObject
/// Initailize <code>OTVEvent</code> instance with parameters
/// \param timestamp the timestamp of the event
///
/// \param type the type of the event. SDK generated events will have types from <code>EventType</code>
///
/// \param command the command of the event. SDK generated events will have commands from <code>EventCommand</code>
///
/// \param extra optional extra information for the event. SDK generated events will have extras formatted as a JSON string, with keys from <code>ExtraKey</code>
///
///
/// returns:
/// an event instance
- (nonnull instancetype)initWithTimestamp:(NSDate * _Nonnull)timestamp type:(NSString * _Nonnull)type command:(NSString * _Nonnull)command extra:(NSString * _Nullable)extra OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A timeline of events generated by the SDK
SWIFT_CLASS("_TtC9OPYSDKFPS16OTVEventTimeline")
@interface OTVEventTimeline : NSObject
/// The global instance of the event timeline
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) OTVEventTimeline * _Nonnull shared;)
+ (OTVEventTimeline * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Set whether the timeline should capture events or not.
/// \param enable whether events added to the timeline should be kept or not
///
- (void)enableTimeline:(BOOL)enable;
/// Returns whether the timeline is enabled for capturing events.
- (BOOL)isEnabled SWIFT_WARN_UNUSED_RESULT;
/// Returns all events that have been recorded.
- (NSArray<OTVEvent *> * _Nonnull)getTimelineList SWIFT_WARN_UNUSED_RESULT;
/// Returns the latest events that have been recorded, up to the specified limit.
/// \param limit The max number of latest events to return
///
- (NSArray<OTVEvent *> * _Nonnull)getTimelineListWithLimit:(NSInteger)limit SWIFT_WARN_UNUSED_RESULT;
/// Returns the events that were recorded between the specified Dates.
/// \param fromDate The earliest Date for events to include
///
/// \param toDate The latest Date for events to include
///
- (NSArray<OTVEvent *> * _Nonnull)getTimelineListFrom:(NSDate * _Nonnull)fromDate to:(NSDate * _Nonnull)toDate SWIFT_WARN_UNUSED_RESULT;
/// Returns all the events that have been recorded with the specified type.
/// \param type The type of events to return
///
- (NSArray<OTVEvent *> * _Nonnull)getTimelineListWithType:(NSString * _Nonnull)type SWIFT_WARN_UNUSED_RESULT;
/// Adds the specified event data to the timeline
/// \param type The type of the event
///
/// \param command The command of the event
///
/// \param extra Optional extra information for the event
///
- (void)addToTimelineWithType:(NSString * _Nonnull)type command:(NSString * _Nonnull)command extra:(NSString * _Nullable)extra;
/// Removes all events from the timeline that were added prior to the specified Date.
/// \param olderThan The reference Date to remove logs earlier than
///
- (void)removeTimelineWithOlderThan:(NSDate * _Nonnull)olderThan;
@end


/// Analyzer for <code>OTVEventTimeline</code> to report startup/zapping time.
/// note:
/// If you are playing back two streams at the same time the results from this class are undefined.
SWIFT_CLASS("_TtC9OPYSDKFPS24OTVEventTimelineAnalyzer")
@interface OTVEventTimelineAnalyzer : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// <code>OTVIFrameThumbnailError</code> is an enum that represent they type of error associated with OTVThumbnail I-Frames
typedef SWIFT_ENUM_NAMED(NSInteger, OTVThumbnailError, "OTVIFrameThumbnailError", open) {
  OTVThumbnailErrorPositionError = 1,
  OTVThumbnailErrorItemError = 2,
};


SWIFT_CLASS("_TtC9OPYSDKFPS15OTVIframeTracks")
@interface OTVIframeTracks : NSObject
@property (nonatomic, readonly) NSInteger bandwith;
@property (nonatomic, readonly) NSInteger averageBandwidth;
@property (nonatomic, readonly, copy) NSString * _Nullable uri;
@property (nonatomic, readonly, copy) NSString * _Nullable codecs;
@property (nonatomic, readonly) CGSize resolution;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// SSM session renewal mode
typedef SWIFT_ENUM_NAMED(NSInteger, OTVLicenseRenewType, "OTVLicenseRenewType", open) {
  OTVLicenseRenewTypeHeartbeat = 0,
  OTVLicenseRenewTypeEnforced = 1,
};

/// License request type
typedef SWIFT_ENUM_NAMED(NSInteger, OTVLicenseRequestType, "OTVLicenseRequestType", open) {
  OTVLicenseRequestTypeRequest = 0,
  OTVLicenseRequestTypeRenewal = 1,
};

@class OTVStreamInfo;
enum OTVMediaSelectionOptions : NSInteger;
@class OTVStreamDrmInfo;

/// The media information of the <code>OTVPersistenceAsset</code>
SWIFT_CLASS("_TtC9OPYSDKFPS12OTVMediaInfo")
@interface OTVMediaInfo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// The asset Duration
@property (nonatomic, readonly) double duration;
/// The selected bandwidth to download (Deprecated, please use selectedBitrate)
@property (nonatomic, readonly) double selectedBandwidth SWIFT_DEPRECATED_MSG("", "selectedBitrate");
/// Return the selected bitrate of the  download
@property (nonatomic, readonly) double selectedBitrate;
/// Return the  selected resolution of the download
@property (nonatomic, readonly) CGSize selectedResolution;
/// Return the estimated size of the selected download
@property (nonatomic, readonly) uint64_t selectedEstimateSize;
/// The selected video track to download.
/// Please set one of the values returned from <code>availableStreamInfo</code>
/// note:
///
/// <ul>
///   <li>
///     Set this value only before the download start, otherwise it has no effect.
///   </li>
/// </ul>
@property (nonatomic, strong) OTVStreamInfo * _Nullable selectedStreamInfo;
/// The AVMediaSelectionOption to be chosen for the asset being download. Either all (all trakcs) or defualt (default tracks)
@property (nonatomic) enum OTVMediaSelectionOptions mediaSelections;
/// The availble iFrame tracks for the media content
@property (nonatomic, readonly, copy) NSArray<OTVIframeTracks *> * _Nullable availableIFrameTracks;
/// The list of availble video tracks to download and the media info assosiated
@property (nonatomic, readonly, copy) NSArray<OTVStreamInfo *> * _Nullable availableStreamInfo;
@property (nonatomic, readonly, copy) NSArray<OTVStreamDrmInfo *> * _Nullable availableDrmInfo;
@end


typedef SWIFT_ENUM(NSInteger, OTVMediaSelectionOptions, open) {
/// Preferred media tracks assoiciated with the asset
  OTVMediaSelectionOptionsPerferred = 1,
/// All media tracks assoiciated with the asset
  OTVMediaSelectionOptionsAll = 2,
};


SWIFT_CLASS("_TtC9OPYSDKFPS14OTVMediaTracks")
@interface OTVMediaTracks : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable type;
@property (nonatomic, readonly, copy) NSString * _Nullable name;
@property (nonatomic, readonly, copy) NSString * _Nullable language;
@property (nonatomic, readonly, copy) NSString * _Nullable isDefault;
@property (nonatomic, readonly, copy) NSString * _Nullable autoSelect;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// The <code>OTVNetworkAnalytics</code> class provides access to playback and network statistics.
/// note:
/// Not all values will be available immediately due to being accumulated over time
SWIFT_CLASS("_TtC9OPYSDKFPS19OTVNetworkAnalytics")
@interface OTVNetworkAnalytics : NSObject
/// Network analytics related to adaptive streaming
@property (nonatomic, readonly, strong) id <AdaptiveStreaming> _Nonnull adaptiveStreaming;
/// Network analytics related to network usage
@property (nonatomic, readonly, strong) id <NetworkUsage> _Nonnull networkUsage;
/// Network analytics related to the content server
@property (nonatomic, readonly, strong) id <ContentServer> _Nonnull contentServer;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC9OPYSDKFPS22OTVOutputDeviceMonitor")
@interface OTVOutputDeviceMonitor : NSObject
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, OTVOutputDeviceType, open) {
/// Digital output consists of HDMI output from HDMI adapters.
/// These can be connected to iOS,iPadOS and tvOS devices.
  OTVOutputDeviceTypeDigital = 1,
/// Airplay output can be setup between an iOS/iPadOS device to a tvOS device.
  OTVOutputDeviceTypeAirplay = 2,
/// Screen recording can be activated by an iOS/iPadOS device by clicking the recording button from the control pannel.
  OTVOutputDeviceTypeRecording = 3,
/// mirroring output can be setup between an iOS/iPadOS device to a tvOS device.
  OTVOutputDeviceTypeMirroring = 4,
/// This is an unknown type of output.
  OTVOutputDeviceTypeUnknown = 5,
};


SWIFT_CLASS("_TtC9OPYSDKFPS21OTVPersistLicenseInfo")
@interface OTVPersistLicenseInfo : NSObject
/// The license duration in seconds
@property (nonatomic) int64_t duration;
/// The license Info passed from the token in the form of a JSON String.
@property (nonatomic, copy) NSString * _Nullable licenseInfomation;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

enum OTVPersistenceDRMType : NSInteger;
@protocol OTVAVURLAssetExtension;

/// Downloads are represented by the objects of the class <code>OTVPersistenceAsset</code>.
/// They have a <code>OTVDownloadState</code> to reflect their lifecycle.
SWIFT_CLASS("_TtC9OPYSDKFPS19OTVPersistenceAsset")
@interface OTVPersistenceAsset : NSObject
/// Unique identifier for the asset
@property (nonatomic, readonly, copy) NSString * _Nonnull uuid;
/// Title of the asset
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
/// URL of the asset
@property (nonatomic, readonly, copy) NSString * _Nonnull url;
/// Progress of the asset download
@property (nonatomic, readonly) double percentComplete;
/// Returns the error details of the failure.
/// <ul>
///   <li>
///     This field applies only if the <code>downloadError</code> is not  <code>.noError</code>, returns <code>nil</code> otherwise
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nullable error;
/// Returns the failure reason of the download.
/// <ul>
///   <li>
///     This field applies only if the state is <code>error</code>, returns <code>nil</code> otherwise
///   </li>
/// </ul>
@property (nonatomic, readonly) enum OTVDownloadError downloadError;
/// The asset ID
@property (nonatomic, readonly, copy) NSString * _Nullable identifier;
/// The total size downloaded for the downloaded/downloading asset in bytes
@property (nonatomic, readonly) uint64_t totalSizeDownloaded;
/// The DRM type of the asset
@property (nonatomic, readonly) enum OTVPersistenceDRMType drmMode;
/// The OTVMediaInfo for the asset
@property (nonatomic, readonly, strong) OTVMediaInfo * _Nullable mediaInfo;
/// The OTVPersistLicenseInfo for the asset
@property (nonatomic, readonly, strong) OTVPersistLicenseInfo * _Nullable licenseInfo;
- (void)renewLicenseWithDelegate:(id <OTVLicenseDelegate> _Nonnull)delegate options:(NSDictionary<NSString *, id> * _Nullable)options;
/// Setup FPS license delegate.
/// note:
///
/// <ul>
///   <li>
///     The <code>OTVPersistenceAsset</code> object MUST be in state `prepared, otherwise calling this function has no effect.
///   </li>
/// </ul>
/// <ul>
///   <li>
///     Parameters:
///     urlAssetExtension: An object implements protocol <code>OTVAVURLAssetExtension</code>, e.g. <code>OTVPRMAVURLAsset</code>
///   </li>
/// </ul>
- (void)setupFPSWith:(id <OTVLicenseDelegate> _Nonnull)delegate;
/// Setup PRM for a download <code>OTVPRMAVURLAsset</code>.
/// note:
///
/// <ul>
///   <li>
///     The <code>OTVPersistenceAsset</code> object MUST be in one state from <code>notDownloaded</code>, <code>prepared</code> or <code>preparing</code>, otherwise calling this function has no effect.
///   </li>
/// </ul>
/// <ul>
///   <li>
///     Parameters:
///     urlAssetExtension: An object implements protocol <code>OTVAVURLAssetExtension</code>
///   </li>
/// </ul>
- (void)setupPRMFor:(id <OTVAVURLAssetExtension> _Nonnull)urlAssetExtension;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



enum OTVDownloadState : NSInteger;

@interface OTVPersistenceAsset (SWIFT_EXTENSION(OPYSDKFPS))
/// Current state of the asset
@property (nonatomic, readonly) enum OTVDownloadState state;
@end


/// ObjectiveC compatible enumeration of the possible states of a persistence asset.
typedef SWIFT_ENUM_NAMED(NSInteger, OTVDownloadState, "OTVPersistenceAssetState", open) {
/// The initial state.
  OTVDownloadStateNotDownloaded = 0,
/// OTVPersistenceAsset is being prepared.
  OTVDownloadStatePreparing = 1,
/// OTVPersistenceAsset is prepared and ready to be downloaded.
  OTVDownloadStatePrepared = 2,
/// Download is in progress.
  OTVDownloadStateDownloading = 3,
/// Download has been paused.
  OTVDownloadStatePaused = 4,
/// Download has completed.
  OTVDownloadStateDownloaded = 5,
/// An error has occurred during attempt to download.
  OTVDownloadStateError = 6,
};

/// ObjectiveC compatible enumeration of the possible DRM types of a persistence asset.
typedef SWIFT_ENUM(NSInteger, OTVPersistenceDRMType, open) {
/// Asset is of DRM Type PRM
  OTVPersistenceDRMTypeFps = 1,
/// Asset is of DRM Type FPS
  OTVPersistenceDRMTypePrm = 2,
/// Asset is of unknown DRM
  OTVPersistenceDRMTypeUnKnownDrm = 100,
/// Asset is clear
  OTVPersistenceDRMTypeNoDrm = 200,
};

@class AVMediaSelection;

/// <code>OTVPersistenceManager</code> is a singleton that manages all download related functionality.
/// It utilises <code>OTVDownloadingAssetManager</code> for <em>outstanding</em> downloads and <code>OTVAssetsManager</code> for <em>completed</em> downloads.
SWIFT_CLASS("_TtC9OPYSDKFPS21OTVPersistenceManager")
@interface OTVPersistenceManager : NSObject
/// Persistence Manager singleton instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) OTVPersistenceManager * _Nonnull shared;)
+ (OTVPersistenceManager * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// Start a media stream dowloading.
/// note:
/// You MUST NOT share the same license delegate instance for multiple downloading.
/// \param urlAsset Asset needs to be downloaded
///
/// \param title Stream’s title
///
/// \param licenseDelegate Delegate to fetch the license
///
/// \param artwork artwork Data
///
/// \param options download options
///
///
/// returns:
/// an asset created for this download.
- (OTVPersistenceAsset * _Nullable)startDownloadWithUrlAsset:(AVURLAsset * _Nonnull)urlAsset title:(NSString * _Nonnull)title licenseDelegate:(id <OTVLicenseDelegate> _Nullable)licenseDelegate artwork:(NSData * _Nullable)artwork options:(NSDictionary<NSString *, id> * _Nullable)options SWIFT_WARN_UNUSED_RESULT;
/// Start Preparing a media stream ready for dowloading.
/// note:
///
/// <ul>
///   <li>
///     To begin the download you must wait for the prepared download state on the OTVPersistenceAsset returned here.
///   </li>
///   <li>
///     Once the OTVPersistenceAsset has entered <code>prepared</code> state:
///     <ul>
///       <li>
///         You can check the mediaInfo values on the OTVPersistenceAsset
///       </li>
///       <li>
///         You can query the <code>OTVPersistenceAsset.mediaInfo.availableStreamInfo</code> to see all the information needed to start downloading the asset.
///       </li>
///       <li>
///         You can query the <code>OTVPersistenceAsset.mediaInfo.availableDrmInfo</code> to get the drm information of the asset.
///       </li>
///     </ul>
///   </li>
///   <li>
///     You SHOULD retain the object returned from preparedDownload, and pass the object to call startDownload: persistenceAsset… when state is changed to Prepared
///   </li>
/// </ul>
/// \param url Url of asset needs to be downloaded
///
/// \param title Stream’s title
///
///
/// returns:
/// an asset created for this download.
- (OTVPersistenceAsset * _Nonnull)prepareDownloadWithUrl:(NSURL * _Nonnull)url title:(NSString * _Nonnull)title SWIFT_WARN_UNUSED_RESULT;
/// Start a media stream dowloading for a <code>OTVPersistenceAsset</code>
/// note:
///
/// <ul>
///   <li>
///     You MUST call <code>prepareDownload</code> and wait for state <code>Prepared</code> on the <code>OTVPersistenceAsset</code> before calling this function
///     <ul>
///       <li>
///         If the stream is FPS encrypted, you MUST call <code>setupFPS:</code> on the prepared <code>OTVPersistenceAsset</code> before calling this function, and pass an <code>OTVLicenseDelegate</code> instance;
///       </li>
///       <li>
///         If the stream is PRM encrypted, you MUST call <code>setupPRM:</code> on the prepared <code>OTVPersistenceAsset</code> before call this function, and pass an <code>OTVPRMAVURLAsset</code> object;
///       </li>
///       <li>
///         If the stream is clear one, you SHOULD NOT call <code>setupFPS:</code> or <code>setupPRM:</code> on the prepared <code>OTVPersistenceAsset</code>.
///       </li>
///       <li>
///         You can set a number of values on the <code>OTVPersistenceAsset</code> to choose what resolution and bitrate you want to download
///       </li>
///       <li>
///         You can do this by setting <code>OTVPersistenceAsset.mediaInfo.selectedStreamInfo</code> from selection one of the <code>OTVPersistenceAsset.mediaInfo.availableStreamInfo</code>
///       </li>
///       <li>
///         If no value is set for <code>OTVPersistenceAsset.mediaInfo.selectedStreamInfo</code> we will check the <code>options</code> value passed into this function.
///       </li>
///       <li>
///         If neither of these values are set then we will use the highest possible value you are able to download.
///       </li>
///     </ul>
///   </li>
/// </ul>
/// \param asset an object of <code>OTVPersistenceAsset</code> in <code>prepared</code> state
///
/// \param artwork artwork Data
///
/// \param options download options
///
/// \param avMediaSelectionOptions the media selection to download, if it is not set, the default selection will be download
///
///
/// returns:
/// <code>True</code> if download start successful, <code>False</code> if there is some error, e.g. the <code>asset</code> is not in <code>prepared</code> state.
- (BOOL)startDownloadWithAsset:(OTVPersistenceAsset * _Nonnull)asset artwork:(NSData * _Nullable)artwork options:(NSDictionary<NSString *, id> * _Nullable)options avMediaSelectionOptions:(NSArray<AVMediaSelection *> * _Nullable)avMediaSelectionOptions SWIFT_WARN_UNUSED_RESULT;
/// Start a media stream dowloading for a <code>OTVPersistenceAsset</code>
/// note:
///
/// <ul>
///   <li>
///     You MUST call <code>prepareDownload</code> and wait for state <code>Prepared</code> on the <code>OTVPersistenceAsset</code> before calling this function
///     <ul>
///       <li>
///         If the stream is FPS encrypted, you MUST call <code>setupFPS:</code> on the prepared <code>OTVPersistenceAsset</code> before calling this function, and pass an <code>OTVLicenseDelegate</code> instance;
///       </li>
///       <li>
///         If the stream is PRM encrypted, you MUST call <code>setupPRM:</code> on the prepared <code>OTVPersistenceAsset</code> before call this function, and pass an <code>OTVPRMAVURLAsset</code> object;
///       </li>
///       <li>
///         If the stream is clear one, you SHOULD NOT call <code>setupFPS:</code> or <code>setupPRM:</code> on the prepared <code>OTVPersistenceAsset</code>.
///       </li>
///       <li>
///         You can set a number of values on the <code>OTVPersistenceAsset</code> to choose what resolution and bitrate you want to download
///       </li>
///       <li>
///         You can do this by setting <code>OTVPersistenceAsset.mediaInfo.selectedStreamInfo</code> from selection one of the <code>OTVPersistenceAsset.mediaInfo.availableStreamInfo</code>
///       </li>
///       <li>
///         If no value is set for <code>OTVPersistenceAsset.mediaInfo.selectedStreamInfo</code> we will check the <code>options</code> value passed into this function.
///       </li>
///       <li>
///         If neither of these values are set then we will use the highest possible value you are able to download.
///       </li>
///     </ul>
///   </li>
/// </ul>
/// \param asset an object of <code>OTVPersistenceAsset</code> in <code>prepared</code> state
///
/// \param artwork artwork Data
///
/// \param options download options
///
///
/// returns:
/// <code>True</code> if download start successful, <code>False</code> if there is some error, e.g. the <code>asset</code> is not in <code>prepared</code> state.
- (BOOL)startDownloadWithAsset:(OTVPersistenceAsset * _Nonnull)asset artwork:(NSData * _Nullable)artwork options:(NSDictionary<NSString *, id> * _Nullable)options SWIFT_WARN_UNUSED_RESULT;
/// Return downloading and downloaded assets.
- (NSArray<OTVPersistenceAsset *> * _Nullable)getDownloads SWIFT_WARN_UNUSED_RESULT;
/// Pause the downloading of assigned asset.
/// \param asset the asset to be paused.
///
- (BOOL)pauseDownloadWithAsset:(OTVPersistenceAsset * _Nonnull)asset SWIFT_WARN_UNUSED_RESULT;
/// Resume the paused downloading asset.
/// \param asset the asset to be resumed.
///
- (BOOL)resumeDownloadWithAsset:(OTVPersistenceAsset * _Nonnull)asset SWIFT_WARN_UNUSED_RESULT;
/// Cancel or remove the asset.
/// \param asset the asset to be cancelled or removed.
///
- (BOOL)deleteDownloadWithAsset:(OTVPersistenceAsset * _Nonnull)asset SWIFT_WARN_UNUSED_RESULT;
@end



@interface OTVPersistenceManager (SWIFT_EXTENSION(OPYSDKFPS))
- (int64_t)totalDiskSpaceInBytes SWIFT_WARN_UNUSED_RESULT;
- (int64_t)freeDiskSpaceInBytes SWIFT_WARN_UNUSED_RESULT;
- (int64_t)usedDiskSpaceInBytes SWIFT_WARN_UNUSED_RESULT;
@end

@protocol Player;
@protocol Rendering;

/// The <code>OTVPlaybackAnalytics</code> class provides access to playback and playback statistics.
SWIFT_CLASS("_TtC9OPYSDKFPS20OTVPlaybackAnalytics")
@interface OTVPlaybackAnalytics : NSObject
/// Playback analytics related to the player
@property (nonatomic, readonly, strong) id <Player> _Nonnull player;
/// Playback analytics related to the rendering
@property (nonatomic, readonly, strong) id <Rendering> _Nonnull rendering;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// :nodoc:
SWIFT_CLASS_NAMED("OTVSDKInternal")
@interface OTVSDK : NSObject
/// :nodoc:
+ (void)loadWithLicence:(NSString * _Nullable)licence;
/// :nodoc:
+ (void)setLoggingWithLevel:(OTVLogType)level;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// The OTVSSMLicenseResponse is a container class used to hold the full license response (license/ckc data, the heartbeat period and the renewal type)
SWIFT_CLASS("_TtC9OPYSDKFPS21OTVSSMLicenseResponse")
@interface OTVSSMLicenseResponse : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// <code>OTVSSPLicenseDelegate</code> is a default implementation of SSP with SSM Service.
SWIFT_CLASS("_TtC9OPYSDKFPS21OTVSSPLicenseDelegate")
@interface OTVSSPLicenseDelegate : OTVCommonLicenseDelegate
/// Set the type for the HTTP requesting headers
/// \param type String value of HTTP header type. Defaults to nv-authorizations. If an empty string is passed it was also default to nv-authorizations
///
- (void)setHTTPHeaderTypeWithType:(NSString * _Nonnull)type;
/// Creates an instance of <code>OTVSSPLicenceDelegate</code>.
/// \param certificateURL URL of certificate file.
///
/// \param licenseURL URL of license request.
///
/// \param ssmServerURL Optional URL of SSM service request. Default is nil if SSM service not required.
///
/// \param syncSSMSetupTeardown If ssmServerURL is provided this defines whether the setup and teardown network requests block the main thread or not. Default is to block.
///
- (nonnull instancetype)initWithCertificateURL:(NSURL * _Nonnull)certificateURL licenseURL:(NSURL * _Nonnull)licenseURL ssmServerURL:(NSURL * _Nullable)ssmServerURL syncSSMSetupTeardown:(BOOL)syncSSMSetupTeardown OBJC_DESIGNATED_INITIALIZER;
/// Creates an instance of <code>OTVSSPLicenceDelegate</code>.
/// \param certificateURL URL of certificate file.
///
/// \param licenseURL URL of license request.
///
/// \param ssmServerURL Optional URL of SSM service request.
///
- (nonnull instancetype)initWithCertificateURL:(NSURL * _Nonnull)certificateURL licenseURL:(NSURL * _Nonnull)licenseURL ssmServerURL:(NSURL * _Nullable)ssmServerURL;
/// Creates an instance of <code>OTVSSPLicenceDelegate</code>.
/// \param certificateURL URL of certificate file.
///
/// \param licenseURL URL of license request.
///
- (nonnull instancetype)initWithCertificateURL:(NSURL * _Nonnull)certificateURL licenseURL:(NSURL * _Nonnull)licenseURL;
- (NSDictionary<NSString *, NSString *> * _Nullable)generateHTTPHeadersWithAssetID:(NSString * _Nonnull)assetID SWIFT_WARN_UNUSED_RESULT;
- (NSURL * _Nonnull)getLicenseRequestUrl SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)getCkcFromLicenseResponseWithResponse:(NSDictionary<NSString *, id> * _Nonnull)response SWIFT_WARN_UNUSED_RESULT;
- (NSData * _Nullable)ckcMessageWithSpc:(NSData * _Nonnull)spc assetID:(NSString * _Nonnull)assetID session:(AVContentKeySession * _Nonnull)session keyRequest:(AVContentKeyRequest * _Nonnull)keyRequest SWIFT_WARN_UNUSED_RESULT;
/// Set the token and the url which associated with the stream.
/// note:
/// If repeated license request require a new media token please use setToken() as any repeated license request will use the original token set from this function.
/// \param token the stream’s SSP specific media token.
///
/// \param url URL of the stream.
///
/// \param success closure for when the stream token and url are sucessfully set. Default to empty.
///
/// \param failure closure for when the stream token and url fail to be set. Default to empty.
///
- (void)setStreamWithToken:(NSString * _Nonnull)token with:(NSURL * _Nonnull)url success:(void (^ _Nonnull)(void))success failure:(void (^ _Nonnull)(void))failure;
/// Application to set the initial stream token and callback which will be used by SDK to request for a new SSP content token, when a new license is requested.
/// note:
/// If repeated license requests do not need a new media token, please use setStream() as this function will request a new media token for each licnese request after the first.
/// \param initialToken The stream’s SSP specific media token to be used for the initial playback
///
/// \param tokenCallback Callback to be used to request the new media token. This callback is fired when a new licnese request is generated.
///
- (void)setTokenWithInitialToken:(NSString * _Nonnull)initialToken tokenCallback:(NSString * _Nonnull (^ _Nonnull)(void))tokenCallback;
@end


SWIFT_CLASS("_TtC9OPYSDKFPS16OTVStreamDrmInfo")
@interface OTVStreamDrmInfo : NSObject
/// The DRM type of the <code>OTVPersistenceAsset</code>
@property (nonatomic, readonly) enum OTVPersistenceDRMType drmType;
/// The DRM key information data from manifest
@property (nonatomic, readonly, copy) NSString * _Nonnull keyInfo;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// The stream information of the <code>OTVPersistenceAsset</code>
SWIFT_CLASS("_TtC9OPYSDKFPS13OTVStreamInfo")
@interface OTVStreamInfo : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// The asset Duration
@property (nonatomic, readonly) double duration;
/// The bandwidth of the media content
@property (nonatomic, readonly) double bitrate;
/// The estimated size of the media content
@property (nonatomic) uint64_t totalSizeEstimate;
/// The Resolution of the media content
@property (nonatomic, readonly) CGSize resolution;
/// The codecs of the media content
@property (nonatomic, readonly, copy) NSString * _Nonnull codecs;
@end


/// This class can be used to display I-Frames from a stream, e.g. for display of thumbnails while seeking.
/// The <code>URL</code> provided to the initialiser must point to a HLS playlist with I-Frames, otherwise the <code>hasThumbnails</code> function will return <code>false</code> and the view won’t render thumbnails.
/// note:
/// <code>hasThumbnails</code> will return <code>false</code> immediately after initalisation, even for a playlist that has I-Frames. This is because the playlist needs to first be downloaded and checked for I-Frames.
SWIFT_CLASS("_TtC9OPYSDKFPS16OTVThumbnailView")
@interface OTVThumbnailView : UIView
/// Initialises the view with the specified stream URL and optional frame.
/// \param url the stream URL to receive I-Frames from
///
/// \param frame the frame to create the view with
///
- (nonnull instancetype)initWithUrl:(NSURL * _Nonnull)url frame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
/// :nodoc:
- (void)layoutSubviews;
/// Specifies whether the <code>URL</code> provided to the initaliser points to a HLS playlist with I-Frames or not
- (BOOL)hasThumbnails SWIFT_WARN_UNUSED_RESULT;
/// Specifies which I-Frame the view should render
/// \param seconds The time within the stream for which to render the I-Frame
///
- (void)setTimeToSeconds:(NSTimeInterval)seconds;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end


/// Describes a track, e.g. subtitle or audio track
SWIFT_CLASS("_TtC9OPYSDKFPS12OTVTrackInfo")
@interface OTVTrackInfo : NSObject
/// The type of track
@property (nonatomic, readonly) enum OTVTrackType type;
/// The name of the track
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// The language code of the track
@property (nonatomic, readonly, copy) NSString * _Nullable language;
/// The media type of the track, one of audio, webvtt, cc, smpte_tt, srt, apic or unknown
@property (nonatomic, readonly, copy) NSString * _Nonnull mediaType;
/// The number of channels in the audio track
@property (nonatomic, readonly) NSInteger channelCount;
/// Enumeration of the codec of the track
@property (nonatomic, readonly) NSInteger codec;
/// The accessibility characteristics of the track
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull characteristics;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Defines the track types available on <code>OTVAVPlayer</code>
typedef SWIFT_ENUM(NSInteger, OTVTrackType, open) {
/// Audio tracks
  OTVTrackTypeAudio = 0,
/// Subtitle tracks
  OTVTrackTypeSubtitle = 1,
};


/// Protocol for listening to available tracks changing
SWIFT_PROTOCOL("_TtP9OPYSDKFPS24OTVTracksChangedListener_")
@protocol OTVTracksChangedListener
/// Called when the available tracks have changed
- (void)tracksChanged;
@end

@class AVPlayerLayer;

/// DEPRECATED: Integration Nexguard watermark support on iOS Platform.
/// This class is no longer in use and contains only no-op function stubs.
/// Please refer to the Quickmark documentation for new usage.
SWIFT_CLASS("_TtC9OPYSDKFPS12OTVWatermark")
@interface OTVWatermark : NSObject
/// Deprecated - This function is an empty stub and does nothing.
- (nullable instancetype)initWithSecret:(NSString * _Nonnull)secret OBJC_DESIGNATED_INITIALIZER;
/// Deprecated - This function is an empty stub and does nothing.
- (nullable instancetype)initWithUrl:(NSString * _Nonnull)url token:(NSString * _Nonnull)token tenant:(NSString * _Nonnull)tenant secret:(NSString * _Nonnull)secret OBJC_DESIGNATED_INITIALIZER;
/// Deprecated - This function is an empty stub and does nothing.
- (void)setWithToken:(NSString * _Nonnull)token;
/// Deprecated - This function is an empty stub and does nothing.
- (void)setWithUrl:(NSString * _Nonnull)url;
/// Deprecated - This function is an empty stub and does nothing.
- (void)setWithTenant:(NSString * _Nonnull)tenant;
/// Deprecated - This function is an empty stub and does nothing.
- (void)setWithApiKey:(NSString * _Nonnull)apiKey;
/// Deprecated - This function is an empty stub and does nothing.
@property (nonatomic, readonly, copy) NSString * _Nonnull quickmarkVersion;
/// Deprecated - This function is an empty stub and does nothing.
@property (nonatomic, readonly, copy) NSString * _Nullable quickmarkCoreVersion;
/// Deprecated - This function is an empty stub and does nothing.
- (void)bindWithPlayerView:(UIView * _Nonnull)playerView playerLayer:(AVPlayerLayer * _Nonnull)playerLayer;
/// Deprecated - This function is an empty stub and does nothing
- (void)unbind;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Playback analytics related to the player
SWIFT_PROTOCOL("_TtP9OPYSDKFPS6Player_")
@protocol Player
/// Returns the total amount of buffered content, in seconds.
///
/// returns:
/// the total amount of buffered content, in seconds
- (double)bufferedDuration SWIFT_WARN_UNUSED_RESULT;
/// Returns an array of resoloutions available in the playlist
/// note:
/// This function will make a seperate request for the Master playlist to return all the availableresoloutions. This request is only done once you call this function and only on the first time you call it for that contnet. Every subsiquent call on the same content does not requst the playlist again.
///
/// returns:
/// an array of resoloutions available in the playlist, or nil if unknown
- (NSArray<NSValue *> * _Nullable)availableResoloutions SWIFT_WARN_UNUSED_RESULT;
/// Returns the resoloution of the content being played
///
/// returns:
/// the Resoloution of the content being played as a  CGSzie e.g CGSize(width: 1920, height: 1080) or CGSizeZero if Uknown or Audio only.
- (CGSize)selectedResoloution SWIFT_WARN_UNUSED_RESULT;
/// Returns the accumulated duration, in seconds, until the player item is ready to play.
///
/// returns:
/// the accumulated duration, in seconds, until the player item is ready to play or -1 if uknown
- (double)startUpTime SWIFT_WARN_UNUSED_RESULT;
/// Returns the total number of playback stalls encountered.
///
/// returns:
/// total number of playback stalls encountered.
- (NSInteger)numberOfStalls SWIFT_WARN_UNUSED_RESULT;
/// Returns the playback type can be live, VOD, or from a file. If nil is returned the playback type is unknown.
///
/// returns:
/// the playback type can be live, VOD, or from a file. If nil is returned the playback type is unknown.
- (NSString * _Nullable)playbackType SWIFT_WARN_UNUSED_RESULT;
/// Returns the date and time at which playback began for this event.
///
/// returns:
/// the date and time at which playback began for this event.
- (NSDate * _Nullable)playbackStartDate SWIFT_WARN_UNUSED_RESULT;
/// Returns the offset, in seconds, in the playlist where the last uninterrupted period of playback began.
///
/// returns:
/// the offset, in seconds, in the playlist where the last uninterrupted period of playback began.
- (NSTimeInterval)playbackStartOffset SWIFT_WARN_UNUSED_RESULT;
@end


/// Playback analytics related to the player
SWIFT_PROTOCOL("_TtP9OPYSDKFPS9Rendering_")
@protocol Rendering
/// Returns the total number of dropped video frames
///
/// returns:
/// the total number of dropped video frames
- (NSInteger)frameDrops SWIFT_WARN_UNUSED_RESULT;
/// Returns the total number of dropped dived by the length of watched content
///
/// returns:
/// the total number of dropped dived by the length of watched content
- (NSInteger)frameDropsPerSecond SWIFT_WARN_UNUSED_RESULT;
/// Returns the frame rate of the current content as measured during playback.
///
/// returns:
/// the frame rate of the current content as measured during playback.
- (NSInteger)framesPerSecond SWIFT_WARN_UNUSED_RESULT;
/// Returns the frame rate of the current content as announced in the stream.
/// note:
/// This function will make a seperate request for the Master playlist to return all the stream information. This request is only done once you call this function and only on the first time you call it for that contnet. Every subsiquent call on the same content does not requst the playlist again.
///
/// returns:
/// the frame rate of the current content as announced in the stream.
- (NSInteger)framesPerSecondNominal SWIFT_WARN_UNUSED_RESULT;
@end


#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
